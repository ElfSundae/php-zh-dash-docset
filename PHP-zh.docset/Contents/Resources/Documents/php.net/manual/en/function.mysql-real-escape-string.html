<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN" "http://www.w3.org/TR/html4/loose.dtd">
<html>
 <head>
  <meta http-equiv="content-type" content="text/html; CHARSET=gb2312">
  <title>转义 SQL 语句中使用的字符串中的特殊字符，并考虑到连接的当前字符集</title>

  <meta http-equiv="X-UA-Compatible" content="IE=edge" />
  <link media="all" rel="stylesheet" type="text/css" href="style.css"/>
 </head>
 <body class="docs" class="docs"><div class="navbar navbar-fixed-top">
  <div class="navbar-inner clearfix">
    <ul class="nav" style="width: 100%">
      <li style="float: left;"><a href="function.mysql-query.html">? mysql_query</a></li>
      <li style="float: right;"><a href="function.mysql-result.html">mysql_result ?</a></li>
    </ul>
  </div>
</div>
<div id="breadcrumbs" class="clearfix">
  <ul class="breadcrumbs-container">
    <li><a href="index.html">PHP Manual</a></li>
    <li><a href="ref.mysql.html">MySQL 函数</a></li>
    <li>转义 SQL 语句中使用的字符串中的特殊字符，并考虑到连接的当前字符集</li>
  </ul>
</div>
<div id="layout">
  <div id="layout-content"><div id="function.mysql-real-escape-string" class="refentry">
   <div class="refnamediv">
    <h1 class="refname">mysql_real_escape_string</h1>
    <p class="verinfo">(PHP 4 &gt;= 4.3.0, PHP 5)</p><p class="refpurpose"><span class="refname">mysql_real_escape_string</span> &mdash; <span class="dc-title">
     转义 SQL 语句中使用的字符串中的特殊字符，并考虑到连接的当前字符集
    </span></p>

   </div>
   <div class="refsect1 unknown-seealsp" id="refsect1-function.mysql-real-escape-string-unknown-seealsp">
    <h3 class="title">说明</h3>
     <div class="methodsynopsis dc-description">
      <span class="type">string</span> <span class="methodname"><strong>mysql_real_escape_string</strong></span>
       ( <span class="methodparam"><span class="type">string</span> <code class="parameter">$unescaped_string</code></span>
      [, <span class="methodparam"><span class="type">resource</span> <code class="parameter">$link_identifier</code></span>
     ] )</div>

    <p class="para rdfs-comment">
     本函数将
     <code class="parameter">unescaped_string</code>
     中的特殊字符转义，并计及连接的当前字符集，因此可以安全用于
     <span class="function"><a href="function.mysql-query.html" class="function">mysql_query()</a></span>。
    </p>
    <blockquote class="note"><p><strong class="note">Note</strong>: 
     <span class="simpara">
      <span class="function"><strong>mysql_real_escape_string()</strong></span> 并不转义
      <em>%</em> 和 <em>_</em>。
     </span>
    </p></blockquote>
    <p class="para">
     <div class="example" id="example-1907">
      <p><strong>Example #1 <span class="function"><strong>mysql_real_escape_string()</strong></span> 例子</strong></p>
      <div class="example-contents">
<div class="phpcode"><code><span style="color: #000000">
<span style="color: #0000BB">&lt;?php<br />$item&nbsp;</span><span style="color: #007700">=&nbsp;</span><span style="color: #DD0000">"Zak's&nbsp;and&nbsp;Derick's&nbsp;Laptop"</span><span style="color: #007700">;<br /></span><span style="color: #0000BB">$escaped_item&nbsp;</span><span style="color: #007700">=&nbsp;</span><span style="color: #0000BB">mysql_real_escape_string</span><span style="color: #007700">(</span><span style="color: #0000BB">$item</span><span style="color: #007700">);<br /></span><span style="color: #0000BB">printf&nbsp;</span><span style="color: #007700">(</span><span style="color: #DD0000">"Escaped&nbsp;string:&nbsp;%s\n"</span><span style="color: #007700">,&nbsp;</span><span style="color: #0000BB">$escaped_item</span><span style="color: #007700">);<br /></span><span style="color: #0000BB">?&gt;</span>
</span>
</code></div>
      </div>

      <div class="example-contents"><p>
       以上例子将产生如下输出：
      </p></div>
      <div class="example-contents screen">
<div class="cdata"><pre>
Escaped string: Zak\&#039;s and Derick\&#039;s Laptop
</pre></div>
      </div>
     </div>
    </p>
    <p class="para">
     参见
     <span class="function"><a href="function.mysql-escape-string.html" class="function">mysql_escape_string()</a></span> 和
     <span class="function"><strong>mysql_character_set_name()</strong></span>。
    </p>
   </div>

  </div><div id="usernotes">
 <div class="head">
  <h3 class="title">User Contributed Notes</h3>
 </div>
<div id="allnotes">  <a name="110413""></a>
  <div class="note">
   <strong class="user">sam at numbsafari dot com</strong>
   <a href="#110413" class="date">20-Oct-2012 02:33</a>
   <div class="text">
    <div class="phpcode">
<code><span class="html">
No discussion of escaping is complete without telling everyone that you should basically never use external input to generate interpreted code. This goes for SQL statements, or anything you would call any sort of "eval" function on.
<br />

<br />
So, instead of using this terribly broken function, use parametric prepared statements instead.
<br />

<br />
Honestly, using user provided data to compose SQL statements should be considered professional negligence and you should be held accountable by your employer or client for not using parametric prepared statements.
<br />

<br />
What does that mean?
<br />

<br />
It means instead of building a SQL statement like this:
<br />

<br />
"INSERT INTO X (A) VALUES(".$_POST["a"].")"
<br />

<br />
You should use mysqli's prepare() function (<a href="http://php.net/manual/en/mysqli.prepare.php" rel="nofollow" target="_blank">http://php.net/manual/en/mysqli.prepare.php</a>) to execute a statement that looks like this:
<br />

<br />
"INSERT INTO X (A) VALUES(?)"
<br />

<br />
NB: This doesn't mean you should never generate dynamic SQL statements. What it means is that you should never use user-provided data to generate those statements. Any user-provided data should be passed through as parameters to the statement after it has been prepared.
<br />

<br />
So, for example, if you are building up a little framework and want to do an insert to a table based on the request URI, it's in your best interest to not take the $_SERVER['REQUEST_URI'] value (or any part of it) and directly concatenate that with your query. Instead,&nbsp; you should parse out the portion of the $_SERVER['REQUEST_URI'] value that you want, and map that through some kind of function or associative array to a non-user provided value. If the mapping produces no value, you know that something is wrong with the user provided data.
<br />

<br />
Failing to follow this has been the cause of a number of SQL-injection problems in the Ruby On Rails framework, even though it uses parametric prepared statements. This is how GitHub was hacked at one point. So, no language is immune to this problem. That's why this is a general best practice and not something specific to PHP and why you should REALLY adopt it.
<br />

<br />
Also, you should still do some kind of validation of the data provided by users, even when using parametric prepared statements. This is because that user-provided data will often become part of some generated HTML, and you want to ensure that the user provided data isn't going to cause security problems in the browser.</span>
</code>
    </div>
   </div>
  </div>
 <div class="foot"></div>
  <a name="108125""></a>
  <div class="note">
   <strong class="user">Walter Tross</strong>
   <a href="#108125" class="date">30-Mar-2012 11:20</a>
   <div class="text">
    <div class="phpcode">
<code><span class="html">
For further information:<br />
<a href="http://dev.mysql.com/doc/refman/5.5/en/mysql-real-escape-string.html" rel="nofollow" target="_blank">http://dev.mysql.com/doc/refman/5.5/en/mysql-real-escape-string.html</a><br />
(replace your MySQL version in the URL)</span>
</code>
    </div>
   </div>
  </div>
 <div class="foot"></div>
  <a name="101248""></a>
  <div class="note">
   <strong class="user">feedr</strong>
   <a href="#101248" class="date">05-Dec-2010 05:38</a>
   <div class="text">
    <div class="phpcode">
<code><span class="html">
Just a little function which mimics the original mysql_real_escape_string but which doesn't need an active mysql connection. Could be implemented as a static function in a database class. Hope it helps someone.
<br />

<br />
<span class="default">&lt;?php
<br />
</span><span class="keyword">function </span><span class="default">mysql_escape_mimic</span><span class="keyword">(</span><span class="default">$inp</span><span class="keyword">) {
<br />
&nbsp;&nbsp;&nbsp; if(</span><span class="default">is_array</span><span class="keyword">(</span><span class="default">$inp</span><span class="keyword">))
<br />
&nbsp;&nbsp; &nbsp; &nbsp;&nbsp; return </span><span class="default">array_map</span><span class="keyword">(</span><span class="default">__METHOD__</span><span class="keyword">, </span><span class="default">$inp</span><span class="keyword">);
<br />

<br />
&nbsp;&nbsp;&nbsp; if(!empty(</span><span class="default">$inp</span><span class="keyword">) &amp;&amp; </span><span class="default">is_string</span><span class="keyword">(</span><span class="default">$inp</span><span class="keyword">)) {
<br />
&nbsp;&nbsp; &nbsp; &nbsp;&nbsp; return </span><span class="default">str_replace</span><span class="keyword">(array(</span><span class="string">'\\'</span><span class="keyword">, </span><span class="string">"\0"</span><span class="keyword">, </span><span class="string">"\n"</span><span class="keyword">, </span><span class="string">"\r"</span><span class="keyword">, </span><span class="string">"'"</span><span class="keyword">, </span><span class="string">'"'</span><span class="keyword">, </span><span class="string">"\x1a"</span><span class="keyword">), array(</span><span class="string">'\\\\'</span><span class="keyword">, </span><span class="string">'\\0'</span><span class="keyword">, </span><span class="string">'\\n'</span><span class="keyword">, </span><span class="string">'\\r'</span><span class="keyword">, </span><span class="string">"\\'"</span><span class="keyword">, </span><span class="string">'\\"'</span><span class="keyword">, </span><span class="string">'\\Z'</span><span class="keyword">), </span><span class="default">$inp</span><span class="keyword">);
<br />
&nbsp;&nbsp;&nbsp; }
<br />

<br />
&nbsp;&nbsp;&nbsp; return </span><span class="default">$inp</span><span class="keyword">;
<br />
}
<br />
</span><span class="default">?&gt;</span>
</span>
</code>
    </div>
   </div>
  </div>
 <div class="foot"></div>
  <a name="95915""></a>
  <div class="note">
   <strong class="user">presto dot dk at gmail dot com</strong>
   <a href="#95915" class="date">28-Jan-2010 04:05</a>
   <div class="text">
    <div class="phpcode">
<code><span class="html">
If you want to make sure that the ID you're using to do a query is a number, use sprint() of (int) or intval(), but don't use mysql_real_escape_string.<br />
<br />
There is no difference between ISO-8859-1's number 10 and UTF-8's number 10.</span>
</code>
    </div>
   </div>
  </div>
 <div class="foot"></div>
  <a name="95009""></a>
  <div class="note">
   <strong class="user">strata_ranger at hotmail dot com</strong>
   <a href="#95009" class="date">08-Dec-2009 08:17</a>
   <div class="text">
    <div class="phpcode">
<code><span class="html">
There's an interesting quirk in the example #2 about SQL injection:&nbsp; AND takes priority over OR, so the injected query actually executes as WHERE (user='aidan' AND password='') OR ''='', so instead of returning a database record corresponding to an arbitrary username (in this case 'aidan'), it would actually return ALL database records.&nbsp; In no particular order.&nbsp; So an attacker might be able to log in as any account, but not necessarily with any control over which account it is.<br />
<br />
Of course a potential attacker could simply modify their parameters to target specific users of interest:<br />
<br />
<span class="default">&lt;?php<br />
<br />
</span><span class="comment">// E.g. attacker's values<br />
</span><span class="default">$_POST</span><span class="keyword">[</span><span class="string">'username'</span><span class="keyword">] = </span><span class="string">''</span><span class="keyword">;<br />
</span><span class="default">$_POST</span><span class="keyword">[</span><span class="string">'password'</span><span class="keyword">] = </span><span class="string">"' OR user = 'administrator' AND '' = '"</span><span class="keyword">;<br />
<br />
</span><span class="comment">// Malformed query<br />
</span><span class="default">$query </span><span class="keyword">= </span><span class="string">"SELECT * FROM users WHERE user='</span><span class="default">$_POST</span><span class="keyword">[</span><span class="default">username</span><span class="keyword">]</span><span class="string">' AND password='</span><span class="default">$_POST</span><span class="keyword">[</span><span class="default">password</span><span class="keyword">]</span><span class="string">'"</span><span class="keyword">;<br />
<br />
echo </span><span class="default">$query</span><span class="keyword">;<br />
<br />
</span><span class="comment">// The query sent to MySQL would read:<br />
// SELECT * FROM users WHERE user='' AND password='' OR user='administrator' AND ''='';<br />
// which would allow anyone to gain access to the account named 'administrator'<br />
<br />
</span><span class="default">?&gt;</span>
</span>
</code>
    </div>
   </div>
  </div>
 <div class="foot"></div>
  <a name="92493""></a>
  <div class="note">
   <strong class="user">plgs at ozemail dot com dot au</strong>
   <a href="#92493" class="date">27-Jul-2009 10:05</a>
   <div class="text">
    <div class="phpcode">
<code><span class="html">
Don't forget that if you're using Mysqli (ie, the "improved" Mysql extension) then you need to use the corresponding mysqli function mysqli_real_escape_string().&nbsp; The parameter order is also different.</span>
</code>
    </div>
   </div>
  </div>
 <div class="foot"></div>
  <a name="66836""></a>
  <div class="note">
   <strong class="user">nicolas</strong>
   <a href="#66836" class="date">30-May-2006 10:38</a>
   <div class="text">
    <div class="phpcode">
<code><span class="html">
Note that mysql_real_escape_string doesn't prepend backslashes to \x00, \n, \r, and and \x1a as mentionned in the documentation, but actually replaces the character with a MySQL acceptable representation for queries (e.g. \n is replaced with the '\n' litteral). (\, ', and " are escaped as documented) This doesn't change how you should use this function, but I think it's good to know.</span>
</code>
    </div>
   </div>
  </div>
 <div class="foot"></div>
</div>
</div>
</div></div></body></html>
