<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN" "http://www.w3.org/TR/html4/loose.dtd">
<html>
 <head>
  <meta http-equiv="content-type" content="text/html; CHARSET=gb2312">
  <title>Traversable（遍历）接口</title>

  <meta http-equiv="X-UA-Compatible" content="IE=edge" />
  <link media="all" rel="stylesheet" type="text/css" href="style.css"/>
 </head>
 <body class="docs" class="docs"><div class="navbar navbar-fixed-top">
  <div class="navbar-inner clearfix">
    <ul class="nav" style="width: 100%">
      <li style="float: left;"><a href="reserved.interfaces.html">? 预定义接口</a></li>
      <li style="float: right;"><a href="class.iterator.html">迭代器 ?</a></li>
    </ul>
  </div>
</div>
<div id="breadcrumbs" class="clearfix">
  <ul class="breadcrumbs-container">
    <li><a href="index.html">PHP Manual</a></li>
    <li><a href="reserved.interfaces.html">预定义接口</a></li>
    <li>Traversable（遍历）接口</li>
  </ul>
</div>
<div id="layout">
  <div id="layout-content"><div id="class.traversable" class="reference">

 <h1 class="title">Traversable（遍历）接口</h1>
 

 <div class="partintro"><p class="verinfo">(No version information available, might only be in Git)</p>


  <div class="section" id="traversable.intro">
   <h2 class="title">简介</h2>
   <p class="para">
    检测一个类是否可以使用 <a href="control-structures.foreach.html" class="link">foreach</a> 进行遍历的接口。
   </p>
   <p class="para">
    无法被单独实现的基本抽象接口。相反它必须由 <strong class="classname">IteratorAggregate</strong> 或 <strong class="classname">Iterator</strong> 接口实现。
   </p>
   <blockquote class="note"><p><strong class="note">Note</strong>: 
    <p class="para">
     实现此接口的内建类可以使用  <a href="control-structures.foreach.html" class="link">foreach</a> 进行遍历而无需实现 <strong class="classname">IteratorAggregate</strong> 或 <strong class="classname">Iterator</strong> 接口。
    </p>
   </p></blockquote>
   <blockquote class="note"><p><strong class="note">Note</strong>: 
    <p class="para">
     这是一个无法在 PHP 脚本中实现的内部引擎接口。<strong class="classname">IteratorAggregate</strong> 或 <strong class="classname">Iterator</strong> 接口可以用来代替它。
    </p>
   </p></blockquote>
  </div>


  <div class="section" id="traversable.synopsis">
   <h2 class="title">接口摘要</h2>


   <div class="classsynopsis">
    <div class="ooclass"></div>


    <div class="classsynopsisinfo">
     <span class="ooclass">
      <strong class="classname">Traversable</strong>
     </span>
     {</div>


   }</div>


   <p class="para">
    这个接口没有任何方法，它的作用仅仅是作为所有可遍历类的基本接口。
   </p>

  </div>

 </div>

</div>
<div id="usernotes">
 <div class="head">
  <h3 class="title">User Contributed Notes</h3>
 </div>
<div id="allnotes">  <a name="116377""></a>
  <div class="note">
   <strong class="user">ajf at ajf dot me</strong>
   <a href="#116377" class="date">23-Dec-2014 09:22</a>
   <div class="text">
    <div class="phpcode">
<code><span class="html">
Note that all objects can be iterated over with foreach anyway and it'll go over each property. This just describes whether or not the class implements an iterator, i.e. has custom behaviour.</span>
</code>
    </div>
   </div>
  </div>
 <div class="foot"></div>
  <a name="114519""></a>
  <div class="note">
   <strong class="user">mathdegiovani at gmail dot com</strong>
   <a href="#114519" class="date">03-Mar-2014 10:41</a>
   <div class="text">
    <div class="phpcode">
<code><span class="html">
Note that instanceof Traversable does not work for stdclass objects, so if you are this check (as @kevinpeno) to decide whether you can iterate, it will fail for direct instances.<br />
<br />
In particular:<br />
<br />
<span class="default">&lt;?php<br />
<br />
$obj </span><span class="keyword">= new </span><span class="default">stdclass</span><span class="keyword">();<br />
</span><span class="default">$obj</span><span class="keyword">-&gt;</span><span class="default">prop </span><span class="keyword">= </span><span class="string">'hello'</span><span class="keyword">;<br />
</span><span class="default">var_dump</span><span class="keyword">(</span><span class="default">$obj </span><span class="keyword">instanceof </span><span class="default">Traversable</span><span class="keyword">);<br />
</span><span class="comment">//outputs bool(false)<br />
</span><span class="default">?&gt;<br />
</span><br />
My own solution is to check whether the object also descends from stdclass, but that also fails to catch some objects that are iterable.</span>
</code>
    </div>
   </div>
  </div>
 <div class="foot"></div>
  <a name="99195""></a>
  <div class="note">
   <strong class="user">kevinpeno at gmail dot com</strong>
   <a href="#99195" class="date">02-Aug-2010 07:06</a>
   <div class="text">
    <div class="phpcode">
<code><span class="html">
While you cannot implement this interface, you can use it in your checks to determine if something is usable in for each. Here is what I use if I'm expecting something that must be iterable via foreach.<br />
<br />
<span class="default">&lt;?php<br />
&nbsp;&nbsp;&nbsp; </span><span class="keyword">if( !</span><span class="default">is_array</span><span class="keyword">( </span><span class="default">$items </span><span class="keyword">) &amp;&amp; !</span><span class="default">$items </span><span class="keyword">instanceof </span><span class="default">Traversable </span><span class="keyword">)<br />
&nbsp;&nbsp; &nbsp; &nbsp;&nbsp; </span><span class="comment">//Throw exception here<br />
</span><span class="default">?&gt;</span>
</span>
</code>
    </div>
   </div>
  </div>
 <div class="foot"></div>
</div>
</div>
</div></div></body></html>
