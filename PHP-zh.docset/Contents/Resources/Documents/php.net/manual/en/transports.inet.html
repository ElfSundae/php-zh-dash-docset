<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN" "http://www.w3.org/TR/html4/loose.dtd">
<html>
 <head>
  <meta http-equiv="content-type" content="text/html; CHARSET=gb2312">
  <title>Internet 领域：TCP，UDP，SSL 和 TLS</title>

  <meta http-equiv="X-UA-Compatible" content="IE=edge" />
  <link media="all" rel="stylesheet" type="text/css" href="style.css"/>
 </head>
 <body class="docs" class="docs"><div class="navbar navbar-fixed-top">
  <div class="navbar-inner clearfix">
    <ul class="nav" style="width: 100%">
      <li style="float: left;"><a href="transports.html">? 所支持的套接字传输器（Socket Transports）列表</a></li>
      <li style="float: right;"><a href="transports.unix.html">Unix 领域：Unix 和 UDG ?</a></li>
    </ul>
  </div>
</div>
<div id="breadcrumbs" class="clearfix">
  <ul class="breadcrumbs-container">
    <li><a href="index.html">PHP Manual</a></li>
    <li><a href="transports.html">所支持的套接字传输器（Socket Transports）列表</a></li>
    <li>Internet 领域：TCP，UDP，SSL 和 TLS</li>
  </ul>
</div>
<div id="layout">
  <div id="layout-content"><div id="transports.inet" class="section">
    <h2 class="title">Internet 领域：TCP，UDP，SSL 和 TLS</h2>
    <p class="simpara">PHP 3，PHP 4，PHP 5。 
    <em>ssl://</em>&amp; 
    <em>tls://</em>自 PHP 4.3 起可用。</p>
    <p class="simpara">
    <em>sslv2://</em>&amp; 
    <em>sslv3://</em>自 PHP 5.0.2 起可用。</p>
    <blockquote class="note"><p><strong class="note">Note</strong>: 
      <span class="simpara">如果没有指定传输器，则假定为 
      <em>tcp://</em>。</span>
    </p></blockquote>
    <ul class="itemizedlist">
      <li class="listitem">
        <span class="simpara">
          <em>127.0.0.1</em>
        </span>
      </li>
      <li class="listitem">
        <span class="simpara">
          <em>fe80::1</em>
        </span>
      </li>
      <li class="listitem">
        <span class="simpara">
          <em>www.example.com</em>
        </span>
      </li>
      <li class="listitem">
        <span class="simpara">
          <em>tcp://127.0.0.1</em>
        </span>
      </li>
      <li class="listitem">
        <span class="simpara">
          <em>tcp://fe80::1</em>
        </span>
      </li>
      <li class="listitem">
        <span class="simpara">
          <em>tcp://www.example.com</em>
        </span>
      </li>
      <li class="listitem">
        <span class="simpara">
          <em>udp://www.example.com</em>
        </span>
      </li>
      <li class="listitem">
        <span class="simpara">
          <em>ssl://www.example.com</em>
        </span>
      </li>
      <li class="listitem">
        <span class="simpara">
          <em>sslv2://www.example.com</em>
        </span>
      </li>
      <li class="listitem">
        <span class="simpara">
          <em>sslv3://www.example.com</em>
        </span>
      </li>
      <li class="listitem">
        <span class="simpara">
          <em>tls://www.example.com</em>
        </span>
      </li>
    </ul>
    <p class="simpara">Internet 领域套接字在目标地址中还期望有一个端口号。在 
    <span class="function"><a href="function.fsockopen.html" class="function">fsockopen()</a></span>中在第二个参数中指定，这样就不会影响传输器的 URL。然而在 
    <span class="function"><a href="function.stream-socket-client.html" class="function">stream_socket_client()</a></span>和相关的函数中是用传统的 URL，端口号在传输器 URL 后面以冒号分隔而指定。</p>
    <ul class="itemizedlist">
      <li class="listitem">
        <span class="simpara">
          <em>tcp://127.0.0.1:80</em>
        </span>
      </li>
      <li class="listitem">
        <span class="simpara">
          <em>tcp://[fe80::1]:80</em>
        </span>
      </li>
      <li class="listitem">
        <span class="simpara">
          <em>tcp://www.example.com:80</em>
        </span>
      </li>
    </ul>
    <blockquote class="note"><p><strong class="note">Note</strong>: 
      <strong>带端口号的 IPv6 数字地址</strong><br />
      <span class="simpara">在上面的第二个例子中，IPv4 和主机名的例子只加了一个冒号和端口号，但 IPv6 的地址被放在方括号中：
      <em>[fe80::1]</em>。这是为了将 IPv6 地址中的冒号和用来分隔端口号的冒号区别开来。</span>
    </p></blockquote>
    <p class="simpara">
    <em>ssl://</em>和 
    <em>tls://</em>传输器（仅在 openssl 支持已编译入 PHP 后可用）是 
    <em>tcp://</em>传输器加入 SSL 加密后的扩展。在 PHP 4.3.0 中 OpenSSL 支持必须被静态编译入 PHP，在 PHP 5.0.0 中可以编译为模块或者静态的。</p>
    <p class="simpara">
    <em>ssl://</em>将根据远程服务器的兼容性和参数设置尝试与之建立 SSL V2 或 SSL V3 链接 
    <em>sslv2://</em>和 
    <em>sslv3://</em>将明确的选择 SSL V2 或 SSL V3 协议进行连接。</p>
    <p class="para">
      <table class="doctable table">
        <caption><strong>
        <em>ssl://</em>和 
        <em>tls://</em>传输器的上下文选项（自 PHP 4.3.2 起）</strong></caption>
        
          <thead>
            <tr>
              <th>名称</th>
              <th>用法</th>
              <th>默认值</th>
            </tr>

          </thead>

          <tbody class="tbody">
            <tr>
              <td>
                <em>verify_peer</em>
              </td>
              <td>&amp;true; 或 &amp;false;。用于 SSL 证书请求验证。</td>
              <td>&amp;false;</td>
            </tr>

            <tr>
              <td>
                <em>allow_self_signed</em>
              </td>
              <td>&amp;true; 或 &amp;false;。允许自签名的证书。</td>
              <td>&amp;false;</td>
            </tr>

            <tr>
              <td>
                <em>cafile</em>
              </td>
              <td>本地文件系统中证书授权机构文件的位置，应和 
              <em>verify_peer</em>上下文选项一起使用来认证远端的身份。</td>
              <td class="empty">&nbsp;</td>
            </tr>

            <tr>
              <td>
                <em>capath</em>
              </td>
              <td>如果没有指定 
              <em>cafile</em>或者如果该处没找到证书，则在 
              <em>capath</em>指定的目录中搜索相配的证书。
              <em>capath</em>必须是一个正确的被散列化的证书目录。</td>
              <td class="empty">&nbsp;</td>
            </tr>

            <tr>
              <td>
                <em>local_cert</em>
              </td>
              <td>文件系统中本地证书文件的路径。必须是一个用 PEM 编码并包含你的证书和私人密钥的文件。可以选择包括发行者的证书链。</td>
              <td class="empty">&nbsp;</td>
            </tr>

            <tr>
              <td>
                <em>passphrase</em>
              </td>
              <td>你的 
              <em>local_cert</em>文件编码的 passphrase。</td>
              <td class="empty">&nbsp;</td>
            </tr>

            <tr>
              <td>
                <em>CN_match</em>
              </td>
              <td>所期待的 Common Name。PHP 能进行有限的通配符匹配。如果 Common Name 与此不匹配，连接尝试会失败。</td>
              <td class="empty">&nbsp;</td>
            </tr>

          </tbody>
        
      </table>

    </p>
    <blockquote class="note"><p><strong class="note">Note</strong>: 
      <span class="simpara">因为 
      <em>ssl://</em>是 
      <a href="wrappers.http.html" class="link">
        <em>https://</em>
      </a>和 
      <a href="wrappers.ftp.html" class="link">
        <em>ftps://</em>
      </a>封装协议的底层传输器，适用于 
      <em>ssl://</em>的任何上下文选项也适用于 
      <em>https://</em>和 
      <em>ftps://</em>。</span>
    </p></blockquote>
  </div><div id="usernotes">
 <div class="head">
  <h3 class="title">User Contributed Notes</h3>
 </div>
<div id="allnotes">  <a name="113244""></a>
  <div class="note">
   <strong class="user">christian at lantian dot eu</strong>
   <a href="#113244" class="date">17-Sep-2013 09:46</a>
   <div class="text">
    <div class="phpcode">
<code><span class="html">
@pablo dot livardo&nbsp; :&nbsp; I think that the problem you found is caused by the difference between the client/server encryption methods used.<br />
<br />
The 465 port is used for SMTPS, and the server starts the encryption immediately it receives your connection. So, your code will work.<br />
<br />
The 587 port is used for Submission (MSA or Mail Submission Agent) which works like the port 25. The server accepts your connection and doesn't activate the encryption. If you want an encrypted connection on the port 587, you must connect on it without encryption, you must start to dialog with the server (with EHLO) and after that you must ask the server to start the encrypted connection using the STARTTLS command. The server starts the encryption and now you can start as well the encryption on your client. <br />
<br />
So, in few words, you can not use : <br />
<br />
<span class="default">&lt;?php $fp </span><span class="keyword">= </span><span class="default">fsockopen</span><span class="keyword">(</span><span class="string">"tls://mail.example.com"</span><span class="keyword">, </span><span class="default">587</span><span class="keyword">, </span><span class="default">$errno</span><span class="keyword">, </span><span class="default">$errstr</span><span class="keyword">);&nbsp; </span><span class="default">?&gt;</span>&nbsp; <br />
<br />
but you can use:<br />
<br />
&nbsp;<span class="default">&lt;?php $fp </span><span class="keyword">= </span><span class="default">stream_socket_client</span><span class="keyword">(</span><span class="string">"mail.example.com:587"</span><span class="keyword">, </span><span class="default">$errno</span><span class="keyword">, </span><span class="default">$errstr</span><span class="keyword">); </span><span class="default">?&gt;</span>&nbsp; <br />
<br />
and after you send the STARTTLS command, you can enable the crypto:<br />
<br />
<span class="default">&lt;?php stream_socket_enable_crypto</span><span class="keyword">(</span><span class="default">$fp</span><span class="keyword">, </span><span class="default">true</span><span class="keyword">, </span><span class="default">STREAM_CRYPTO_METHOD_SSLv23_CLIENT</span><span class="keyword">); </span><span class="default">?&gt;<br />
</span><br />
P.S. My previous note on this page was totally wrong, so I ask the php.net admin to remove it.<br />
<br />
:)</span>
</code>
    </div>
   </div>
  </div>
 <div class="foot"></div>
  <a name="113239""></a>
  <div class="note">
   <strong class="user">christian at lantian dot eu</strong>
   <a href="#113239" class="date">17-Sep-2013 05:17</a>
   <div class="text">
    <div class="phpcode">
<code><span class="html">
@pablo dot livardo&nbsp; :&nbsp; I think that the problem you found is caused by the difference between the client/server encryption methods used.<br />
<br />
You tried to access the port 587 using TLS encryption, but the server uses the SSLv3 encryption on this port.<br />
<br />
You can communicate with the Google server on port 465 because on this port the communication is encrypted using TLS and your client is configured to recognize the TLS.<br />
<br />
So, if you want to connect on the Google server over the port 587, you simply must write:<br />
<br />
<span class="default">&lt;?php <br />
$fp </span><span class="keyword">= </span><span class="default">fsockopen</span><span class="keyword">(</span><span class="string">"ssl://mail.example.com"</span><span class="keyword">, </span><span class="default">587</span><span class="keyword">, </span><span class="default">$errno</span><span class="keyword">, </span><span class="default">$errstr</span><span class="keyword">); <br />
</span><span class="default">?&gt;</span> <br />
<br />
instead of:<br />
<br />
<span class="default">&lt;?php <br />
$fp </span><span class="keyword">= </span><span class="default">fsockopen</span><span class="keyword">(</span><span class="string">"tls://mail.example.com"</span><span class="keyword">, </span><span class="default">587</span><span class="keyword">, </span><span class="default">$errno</span><span class="keyword">, </span><span class="default">$errstr</span><span class="keyword">); <br />
</span><span class="default">?&gt;</span> <br />
<br />
:)</span>
</code>
    </div>
   </div>
  </div>
 <div class="foot"></div>
  <a name="99503""></a>
  <div class="note">
   <strong class="user">stefan at example dot com</strong>
   <a href="#99503" class="date">20-Aug-2010 02:42</a>
   <div class="text">
    <div class="phpcode">
<code><span class="html">
Actually, PHP is very able to start with an unencrypted connection and then switch to an encrypted one - refer to <a href="http://php.net/stream_socket_enable_crypto ." rel="nofollow" target="_blank">http://php.net/stream_socket_enable_crypto .</a></span>
</code>
    </div>
   </div>
  </div>
 <div class="foot"></div>
  <a name="95022""></a>
  <div class="note">
   <strong class="user">pablo dot livardo at gmail dot com</strong>
   <a href="#95022" class="date">09-Dec-2009 06:56</a>
   <div class="text">
    <div class="phpcode">
<code><span class="html">
I've been having a problem with a TLS connection.
<br />

<br />
<span class="default">&lt;?php
<br />
$fp </span><span class="keyword">= </span><span class="default">fsockopen</span><span class="keyword">(</span><span class="string">"tls://mail.example.com"</span><span class="keyword">, </span><span class="default">587</span><span class="keyword">, </span><span class="default">$errno</span><span class="keyword">, </span><span class="default">$errstr</span><span class="keyword">);
<br />
</span><span class="default">?&gt;
<br />
</span>
<br />
Which gives me an error of:
<br />

<br />
SSL operation failed with code 1. OpenSSL Error messages: error:1408F10B:SSL routines:SSL3_GET_RECORD:wrong version number
<br />

<br />
I believe this is caused by PHP not being able to start with an unencrypted connection and then switch to encryption even though the functionality is built into OpenSSL.
<br />

<br />
For Google Mail users you can avoid this by using port 465 instead of 587.</span>
</code>
    </div>
   </div>
  </div>
 <div class="foot"></div>
</div>
</div>
</div></div></body></html>
