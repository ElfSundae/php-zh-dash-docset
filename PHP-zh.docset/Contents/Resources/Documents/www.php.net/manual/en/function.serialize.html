<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN" "http://www.w3.org/TR/html4/loose.dtd">
<html>
 <head>
  <meta http-equiv="content-type" content="text/html; CHARSET=gb2312">
  <title>生成值的可存储表示</title>
<link media="all" rel="stylesheet" type="text/css" href="styles/03e73060321a0a848018724a6c83de7f-theme-base.css" />
<link media="all" rel="stylesheet" type="text/css" href="styles/03e73060321a0a848018724a6c83de7f-theme-medium.css" />

  <meta http-equiv="X-UA-Compatible" content="IE=edge" />
  <link media="all" rel="stylesheet" type="text/css" href="style.css"/>
 </head>
 <body class="docs" class="docs"><div class="navbar navbar-fixed-top">
  <div class="navbar-inner clearfix">
    <ul class="nav" style="width: 100%">
      <li style="float: left;"><a href="function.print-r.html">? print_r</a></li>
      <li style="float: right;"><a href="function.settype.html">settype ?</a></li>
    </ul>
  </div>
</div>
<div id="breadcrumbs" class="clearfix">
  <ul class="breadcrumbs-container">
    <li><a href="index.html">PHP Manual</a></li>
    <li><a href="ref.var.html">变量处理函数</a></li>
    <li>生成值的可存储表示</li>
  </ul>
</div>
<div id="layout">
  <div id="layout-content"><div id="function.serialize" class="refentry">
 <div class="refnamediv">
  <h1 class="refname">serialize</h1>
   <p class="verinfo">(PHP 4, PHP 5, PHP 7, PHP 8)</p><p class="refpurpose"><span class="refname">serialize</span> &mdash; <span class="dc-title">生成值的可存储表示</span></p>

 </div>
 
 <div class="refsect1 description" id="refsect1-function.serialize-description">
  <h3 class="title">说明</h3>
   <div class="methodsynopsis dc-description">
    <span class="methodname"><strong>serialize</strong></span>(<span class="methodparam"><span class="type"><a href="language.types.mixed.html" class="type mixed">mixed</a></span> <code class="parameter">$value</code></span>): <span class="type"><a href="language.types.string.html" class="type string">string</a></span></div>

  <p class="para rdfs-comment">
   生成值的可存储表示。
  </p>
  <p class="para">
   这有利于存储或传递 PHP 的值，同时不丢失其类型和结构。
  </p>
  <p class="para">
    想要将已序列化的字符串变回 PHP 的值，可使用
    <span class="function"><a href="function.unserialize.html" class="function">unserialize()</a></span>。
  </p>
 </div>


 <div class="refsect1 parameters" id="refsect1-function.serialize-parameters">
  <h3 class="title">参数</h3>
  <p class="para">
   <dl>
    
     <dt><code class="parameter">value</code></dt>
     <dd>
      <p class="para">
       要序列化的值。<span class="function"><strong>serialize()</strong></span> 处理所有的类型，除了 <span class="type"><a href="language.types.resource.html" class="type resource">resource</a></span> 类型和一些
       <span class="type"><a href="language.types.object.html" class="type object">object</a></span>（见下面的注释）。<span class="function"><strong>serialize()</strong></span>
       甚至可以序列化包含对自身引用的数组。数组/对象内的循环引用也会被存储。其它任何引用都会丢失。
      </p>
      <p class="para">
       序列化对象时，PHP 将尝试在序列化之前调用成员函数 <a href="language.oop5.magic.html#object.serialize" class="link">__serialize()</a> 或
       <a href="language.oop5.magic.html#object.sleep" class="link">__sleep()</a>。这是为了允许对象在序列化之前进行最后一分钟的清理等等。同样，当使用
       <span class="function"><a href="function.unserialize.html" class="function">unserialize()</a></span> 恢复对象时，会调用 <a href="language.oop5.magic.html#object.unserialize" class="link">__unserialize()</a>
       或 <a href="language.oop5.magic.html#object.wakeup" class="link">__wakeup()</a> 成员函数。
      </p>
      <blockquote class="note"><p><strong class="note">Note</strong>: 
       <p class="para">
        对象的 private 成员会在名前添加类名；protected 成员会在名前添加"*"；这些前置值在两边都有 null 字节。
       </p>
      </p></blockquote>
     </dd>
    
   </dl>
  </p>
 </div>


 <div class="refsect1 returnvalues" id="refsect1-function.serialize-returnvalues">
  <h3 class="title">返回值</h3>
  <p class="para">
   返回字符串，包含 <code class="parameter">value</code> 的字节流表示，可以存储在任何地方。
  </p>
  <p class="para">
   注意这可能是包含 null 字节的二进制字符串，需要按原样存储和处理。例如，<span class="function"><strong>serialize()</strong></span>
   的输出通常应该存储在数据库中 的 BLOB 字段，而不是 CHAR 或 TEXT 字段。
  </p>
 </div>


 <div class="refsect1 examples" id="refsect1-function.serialize-examples">
  <h3 class="title">示例</h3>
  <p class="para">
   <div class="example" id="example-5427">
    <p><strong>Example #1 <span class="function"><strong>serialize()</strong></span> 示例</strong></p>
    <div class="example-contents">
<div class="phpcode"><code><span style="color: #000000"><span style="color: #0000BB">&lt;?php<br /></span><span style="color: #FF8000">// $sssion_data 是多维数组，包含当前用户的<br />// 会话信息。可以在请求结束时使用 serialize()<br />// 将其存储在数据库中。<br /><br /></span><span style="color: #0000BB">$conn </span><span style="color: #007700">= </span><span style="color: #0000BB">odbc_connect</span><span style="color: #007700">(</span><span style="color: #DD0000">"webdb"</span><span style="color: #007700">, </span><span style="color: #DD0000">"php"</span><span style="color: #007700">, </span><span style="color: #DD0000">"chicken"</span><span style="color: #007700">);<br /></span><span style="color: #0000BB">$stmt </span><span style="color: #007700">= </span><span style="color: #0000BB">odbc_prepare</span><span style="color: #007700">(</span><span style="color: #0000BB">$conn</span><span style="color: #007700">,<br />      </span><span style="color: #DD0000">"UPDATE sessions SET data = ? WHERE id = ?"</span><span style="color: #007700">);<br /></span><span style="color: #0000BB">$sqldata </span><span style="color: #007700">= array (</span><span style="color: #0000BB">serialize</span><span style="color: #007700">(</span><span style="color: #0000BB">$session_data</span><span style="color: #007700">), </span><span style="color: #0000BB">$_SERVER</span><span style="color: #007700">[</span><span style="color: #DD0000">'PHP_AUTH_USER'</span><span style="color: #007700">]);<br />if (!</span><span style="color: #0000BB">odbc_execute</span><span style="color: #007700">(</span><span style="color: #0000BB">$stmt</span><span style="color: #007700">, </span><span style="color: #0000BB">$sqldata</span><span style="color: #007700">)) {<br />    </span><span style="color: #0000BB">$stmt </span><span style="color: #007700">= </span><span style="color: #0000BB">odbc_prepare</span><span style="color: #007700">(</span><span style="color: #0000BB">$conn</span><span style="color: #007700">,<br />     </span><span style="color: #DD0000">"INSERT INTO sessions (id, data) VALUES(?, ?)"</span><span style="color: #007700">);<br />    if (!</span><span style="color: #0000BB">odbc_execute</span><span style="color: #007700">(</span><span style="color: #0000BB">$stmt</span><span style="color: #007700">, </span><span style="color: #0000BB">array_reverse</span><span style="color: #007700">(</span><span style="color: #0000BB">$sqldata</span><span style="color: #007700">))) {<br />        </span><span style="color: #FF8000">/* Something went wrong.. */<br />    </span><span style="color: #007700">}<br />}<br /></span><span style="color: #0000BB">?&gt;</span></span></code></div>
    </div>

   </div>
  </p>
 </div>


 <div class="refsect1 notes" id="refsect1-function.serialize-notes">
  <h3 class="title">注释</h3>
  <blockquote class="note"><p><strong class="note">Note</strong>: 
   <p class="para">
    注意许多内置 PHP 对象不能序列化。然而，要么实现 <span class="interfacename"><a href="class.serializable.html" class="interfacename">Serializable</a></span> 接口，要么实现 <a href="language.oop5.magic.html#object.serialize" class="link">__serialize()</a>/<a href="language.oop5.magic.html#object.unserialize" class="link">__unserialize()</a>
    或 <a href="language.oop5.magic.html#object.sleep" class="link">__sleep()</a>/<a href="language.oop5.magic.html#object.wakeup" class="link">__wakeup()</a>
    魔术方法的则是可以的。如果内部类不满足这些其中任意一个，则就不能可靠的进行序列化。
   </p>
   <p class="para">
    上述规则有一些历史例外，一些内部对象可以在不实现接口或公开方法的情况下，使其序列化。
   </p>
  </p></blockquote>
  <div class="warning"><strong class="warning">Warning</strong>
   <p class="para">
    当 <span class="function"><strong>serialize()</strong></span> 序列化对象时，命名空间中的类名不要以反斜线开头，以便实现最大兼容性。
   </p>
  </div>
 </div>


 <div class="refsect1 seealso" id="refsect1-function.serialize-seealso">
  <h3 class="title">参见</h3>
  <p class="para">
   <ul class="simplelist">
    <li><span class="function"><a href="function.unserialize.html" class="function" rel="rdfs-seeAlso">unserialize()</a> - 从已存储的表示中创建 PHP 的值</span></li>
    <li><span class="function"><a href="function.var-export.html" class="function" rel="rdfs-seeAlso">var_export()</a> - 输出或返回变量的可解析字符串表示</span></li>
    <li><span class="function"><a href="function.json-encode.html" class="function" rel="rdfs-seeAlso">json_encode()</a> - 对变量进行 JSON 编码</span></li>
    <li><a href="language.oop5.serialization.html" class="link">序列化对象</a></li>
    <li><a href="language.oop5.magic.html#object.sleep" class="link">__sleep()</a></li>
    <li><a href="language.oop5.magic.html#object.wakeup" class="link">__wakeup()</a></li>
    <li><a href="language.oop5.magic.html#object.serialize" class="link">__serialize()</a></li>
    <li><a href="language.oop5.magic.html#object.unserialize" class="link">__unserialize()</a></li>
   </ul>
  </p>
 </div>


</div><div id="usernotes">
 <div class="head">
  <h3 class="title">User Contributed Notes</h3>
 </div>
<div id="allnotes">  <a name="128200""></a>
  <div class="note">
   <strong class="user">mark at bvits dot co dot uk</strong>
   <a href="#128200" class="date">09-Feb-2023 01:05</a>
   <div class="text">
    <div class="phpcode">
<code><span class="html">
There is a type not mentioned in the user notes so far, 'E'.&nbsp; This is the newer Enum class that can be utilised:<br />
<br />
login_security|E:25:"Permission:manageClient"</span>
</code>
    </div>
   </div>
  </div>
 <div class="foot"></div>
  <a name="113305""></a>
  <div class="note">
   <strong class="user">frost at easycast dot ru</strong>
   <a href="#113305" class="date">23-Sep-2013 10:56</a>
   <div class="text">
    <div class="phpcode">
<code><span class="html">
Closures cannot be serialized:<br />
<span class="default">&lt;?php<br />
$func </span><span class="keyword">= function () {echo </span><span class="string">'hello!'</span><span class="keyword">;};<br />
</span><span class="default">$func</span><span class="keyword">(); </span><span class="comment">// prints "hello!"<br />
<br />
</span><span class="default">$result </span><span class="keyword">= </span><span class="default">serialize</span><span class="keyword">(</span><span class="default">$func</span><span class="keyword">);&nbsp; </span><span class="comment">// Fatal error: Uncaught exception 'Exception' with message 'Serialization of 'Closure' is not allowed' <br />
</span><span class="default">?&gt;</span>
</span>
</code>
    </div>
   </div>
  </div>
 <div class="foot"></div>
  <a name="111168""></a>
  <div class="note">
   <strong class="user">nh at ngin dot de</strong>
   <a href="#111168" class="date">21-Jan-2013 09:59</a>
   <div class="text">
    <div class="phpcode">
<code><span class="html">
Serializing floating point numbers leads to weird precision offset errors:<br />
<br />
<span class="default">&lt;?php<br />
<br />
</span><span class="keyword">echo </span><span class="default">round</span><span class="keyword">(</span><span class="default">96.670000000000002</span><span class="keyword">, </span><span class="default">2</span><span class="keyword">);<br />
</span><span class="comment">// 96.67<br />
<br />
</span><span class="keyword">echo </span><span class="default">serialize</span><span class="keyword">(</span><span class="default">round</span><span class="keyword">(</span><span class="default">96.670000000000002</span><span class="keyword">, </span><span class="default">2</span><span class="keyword">));<br />
</span><span class="comment">// d:96.670000000000002;<br />
<br />
</span><span class="keyword">echo </span><span class="default">serialize</span><span class="keyword">(</span><span class="default">96.67</span><span class="keyword">);<br />
</span><span class="comment">// d:96.670000000000002;<br />
<br />
</span><span class="default">?&gt;<br />
</span><br />
Not only is this wrong, but it adds a lot of unnecessary bulk to serialized data. Probably better to use json_encode() instead (which apparently is faster than serialize(), anyway).</span>
</code>
    </div>
   </div>
  </div>
 <div class="foot"></div>
  <a name="109953""></a>
  <div class="note">
   <strong class="user">Andrew B</strong>
   <a href="#109953" class="date">05-Sep-2012 09:42</a>
   <div class="text">
    <div class="phpcode">
<code><span class="html">
When you serialize an array the internal pointer will not be preserved. Apparently this is the expected behavior but was a bit of a gotcha moment for me. Copy and paste example below.
<br />

<br />
<span class="default">&lt;?php
<br />
</span><span class="comment">//Internal Pointer will be 2 once variables have been assigned.
<br />
</span><span class="default">$array </span><span class="keyword">= array();
<br />
</span><span class="default">$array</span><span class="keyword">[] = </span><span class="default">1</span><span class="keyword">;
<br />
</span><span class="default">$array</span><span class="keyword">[] = </span><span class="default">2</span><span class="keyword">;
<br />
</span><span class="default">$array</span><span class="keyword">[] = </span><span class="default">3</span><span class="keyword">;
<br />

<br />
</span><span class="comment">//Unset variables. Internal pointer will still be at 2.&nbsp; &nbsp;&nbsp; 
<br />
</span><span class="keyword">unset(</span><span class="default">$array</span><span class="keyword">[</span><span class="default">0</span><span class="keyword">]);
<br />
unset(</span><span class="default">$array</span><span class="keyword">[</span><span class="default">1</span><span class="keyword">]);
<br />
unset(</span><span class="default">$array</span><span class="keyword">[</span><span class="default">2</span><span class="keyword">]);
<br />

<br />
</span><span class="comment">//Serialize
<br />
</span><span class="default">$serializeArray </span><span class="keyword">= </span><span class="default">serialize</span><span class="keyword">(</span><span class="default">$array</span><span class="keyword">);
<br />

<br />
</span><span class="comment">//Unserialize
<br />
</span><span class="default">$array </span><span class="keyword">= </span><span class="default">unserialize</span><span class="keyword">(</span><span class="default">$serializeArray</span><span class="keyword">);
<br />

<br />
</span><span class="comment">//Add a new element to the array
<br />
//If the internal pointer was preserved, the new array key should be 3.
<br />
//Instead the internal pointer has been reset, and the new array key is 0.
<br />
</span><span class="default">$array</span><span class="keyword">[] = </span><span class="default">4</span><span class="keyword">;
<br />

<br />
</span><span class="comment">//Expected Key - 3
<br />
//Actual Key - 0
<br />
</span><span class="keyword">echo </span><span class="string">"&lt;pre&gt;" </span><span class="keyword">, </span><span class="default">print_r</span><span class="keyword">(</span><span class="default">$array</span><span class="keyword">, </span><span class="default">1</span><span class="keyword">) , </span><span class="string">"&lt;/pre&gt;"</span><span class="keyword">;
<br />
</span><span class="default">?&gt;</span>
</span>
</code>
    </div>
   </div>
  </div>
 <div class="foot"></div>
  <a name="107717""></a>
  <div class="note">
   <strong class="user">Anonymous</strong>
   <a href="#107717" class="date">28-Feb-2012 07:44</a>
   <div class="text">
    <div class="phpcode">
<code><span class="html">
Please! please! please! DO NOT serialize data and place it into your database. Serialize can be used that way, but that's missing the point of a relational database and the datatypes inherent in your database engine. Doing this makes data in your database non-portable, difficult to read, and can complicate queries. If you want your application to be portable to other languages, like let's say you find that you want to use Java for some portion of your app that it makes sense to use Java in, serialization will become a pain in the buttocks. You should always be able to query and modify data in the database without using a third party intermediary tool to manipulate data to be inserted. <br />
<br />
I've encountered this too many times in my career, it makes for difficult to maintain code, code with portability issues, and data that is it more difficult to migrate to other RDMS systems, new schema, etc. It also has the added disadvantage of making it messy to search your database based on one of the fields that you've serialized. <br />
<br />
That's not to say serialize() is useless. It's not... A good place to use it may be a cache file that contains the result of a data intensive operation, for instance. There are tons of others... Just don't abuse serialize because the next guy who comes along will have a maintenance or migration nightmare.</span>
</code>
    </div>
   </div>
  </div>
 <div class="foot"></div>
  <a name="66147""></a>
  <div class="note">
   <strong class="user">egingell at sisna dot com</strong>
   <a href="#66147" class="date">15-May-2006 05:12</a>
   <div class="text">
    <div class="phpcode">
<code><span class="html">
&lt;?<br />
/*<br />
Anatomy of a serialize()'ed value:<br />
<br />
&nbsp;String<br />
&nbsp;s:size:value;<br />
<br />
&nbsp;Integer<br />
&nbsp;i:value;<br />
<br />
&nbsp;Boolean<br />
&nbsp;b:value; (does not store "true" or "false", does store '1' or '0')<br />
<br />
&nbsp;Null<br />
&nbsp;N;<br />
<br />
&nbsp;Array<br />
&nbsp;a:size:{key definition;value definition;(repeated per element)}<br />
<br />
&nbsp;Object<br />
&nbsp;O:strlen(object name):object name:object size:{s:strlen(property name):property name:property definition;(repeated per property)}<br />
<br />
&nbsp;String values are always in double quotes<br />
&nbsp;Array keys are always integers or strings<br />
&nbsp;&nbsp;&nbsp; "null =&gt; 'value'" equates to 's:0:"";s:5:"value";',<br />
&nbsp;&nbsp;&nbsp; "true =&gt; 'value'" equates to 'i:1;s:5:"value";',<br />
&nbsp;&nbsp;&nbsp; "false =&gt; 'value'" equates to 'i:0;s:5:"value";',<br />
&nbsp;&nbsp;&nbsp; "array(whatever the contents) =&gt; 'value'" equates to an "illegal offset type" warning because you can't use an<br />
&nbsp;&nbsp;&nbsp; array as a key; however, if you use a variable containing an array as a key, it will equate to 's:5:"Array";s:5:"value";',<br />
&nbsp;&nbsp; &nbsp; and<br />
&nbsp;&nbsp;&nbsp; attempting to use an object as a key will result in the same behavior as using an array will.<br />
*/<br />
?&gt;</span>
</code>
    </div>
   </div>
  </div>
 <div class="foot"></div>
  <a name="60317""></a>
  <div class="note">
   <strong class="user">MC_Gurk at gmx dot net</strong>
   <a href="#60317" class="date">03-Jan-2006 07:44</a>
   <div class="text">
    <div class="phpcode">
<code><span class="html">
If you are going to serialie an object which contains references to other objects you want to serialize some time later, these references will be lost when the object is unserialized.<br />
The references can only be kept if all of your objects are serialized at once.<br />
That means:<br />
<br />
$a = new ClassA(); <br />
$b = new ClassB($a); //$b containes a reference to $a;<br />
<br />
$s1=serialize($a);<br />
$s2=serialize($b);<br />
<br />
$a=unserialize($s1);<br />
$b=unserialize($s2);<br />
<br />
now b references to an object of ClassA which is not $a. $a is another object of Class A.<br />
<br />
use this:<br />
$buf[0]=$a;<br />
$buf[1]=$b;<br />
$s=serialize($buf);<br />
$buf=unserialize($s);<br />
$a=$buf[0];<br />
$b=$buf[1];<br />
<br />
all references are intact.</span>
</code>
    </div>
   </div>
  </div>
 <div class="foot"></div>
</div>
</div>
</div></div></body></html>
