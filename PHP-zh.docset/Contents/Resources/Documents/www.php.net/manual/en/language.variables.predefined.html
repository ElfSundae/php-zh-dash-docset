<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN" "http://www.w3.org/TR/html4/loose.dtd">
<html>
 <head>
  <meta http-equiv="content-type" content="text/html; CHARSET=gb2312">
  <title>预定义变量</title>
<link media="all" rel="stylesheet" type="text/css" href="styles/03e73060321a0a848018724a6c83de7f-theme-base.css" />
<link media="all" rel="stylesheet" type="text/css" href="styles/03e73060321a0a848018724a6c83de7f-theme-medium.css" />

  <meta http-equiv="X-UA-Compatible" content="IE=edge" />
  <link media="all" rel="stylesheet" type="text/css" href="style.css"/>
 </head>
 <body class="docs" class="docs"><div class="navbar navbar-fixed-top">
  <div class="navbar-inner clearfix">
    <ul class="nav" style="width: 100%">
      <li style="float: left;"><a href="language.variables.basics.html">? 基础</a></li>
      <li style="float: right;"><a href="language.variables.scope.html">变量范围 ?</a></li>
    </ul>
  </div>
</div>
<div id="breadcrumbs" class="clearfix">
  <ul class="breadcrumbs-container">
    <li><a href="index.html">PHP Manual</a></li>
    <li><a href="language.variables.html">变量</a></li>
    <li>预定义变量</li>
  </ul>
</div>
<div id="layout">
  <div id="layout-content"><div id="language.variables.predefined" class="sect1">
   <h2 class="title">预定义变量</h2>

   <p class="para">
    PHP 提供了大量的预定义变量。由于许多变量依赖于运行的服务器的版本和设置，及其它因素，所以并没有详细的说明文档。一些预定义变量在
    PHP 以<a href="features.commandline.html" class="link">命令行</a>形式运行时并不生效。
    详细参阅<a href="reserved.variables.html" class="link">预定义变量</a>一章。
   </p>

   <p class="para">
    PHP 提供了一套附加的预定数组，这些数组变量包含了来自 web
    服务器（如果可用），运行环境，和用户输入的数据。这些数组非常特别，它们在全局范围内自动生效，例如，在任何范围内自动生效。因此通常被称为自动全局变量（autoglobals）或者超全局变量（superglobals）。（PHP
    中没有用户自定义超全局变量的机制。）
    详情参阅<a href="language.variables.superglobals.html" class="link">超全局变量列表</a>。
   </p>

   <blockquote class="note"><p><strong class="note">Note</strong>: 
    <strong>可变变量</strong><br />
    <p class="para">
     超级全局变量不能被用作函数或类方法中的<a href="language.variables.variable.html" class="link">可变变量</a>。
    </p>
   </p></blockquote>

   <p class="para">
    如果某些 <a href="ini.core.html#ini.variables-order" class="link">variables_order</a>
    中的变量没有设定，它们的对应的 PHP 预定义数组也是空的。
   </p>

  </div><div id="usernotes">
 <div class="head">
  <h3 class="title">User Contributed Notes</h3>
 </div>
<div id="allnotes">  <a name="64336""></a>
  <div class="note">
   <strong class="user">johnphayes at gmail dot com</strong>
   <a href="#64336" class="date">12-Apr-2006 10:36</a>
   <div class="text">
    <div class="phpcode">
<code><span class="html">
I haven't found it anywhere else in the manual, so I'll make a note of it here - PHP will automatically replace any dots ('.') in an incoming variable name with underscores ('_'). So if you have dots in your incoming variables, e.g.:<br />
<br />
example.com/page.php?chuck.norris=nevercries<br />
<br />
you can not reference them by the name used in the URI:<br />
//INCORRECT<br />
echo $_GET['chuck.norris'];<br />
<br />
instead you must use:<br />
//CORRECT<br />
echo $_GET['chuck_norris'];</span>
</code>
    </div>
   </div>
  </div>
 <div class="foot"></div>
  <a name="63312""></a>
  <div class="note">
   <strong class="user">DD32=theonly_DD32[&amp;amp;]yahoo.com.au</strong>
   <a href="#63312" class="date">19-Mar-2006 05:43</a>
   <div class="text">
    <div class="phpcode">
<code><span class="html">
I have this function in my main files, it allows for easier SEO for some pages without having to rely on .htaccess and mod_rewrite for some things.<br />
<span class="default">&lt;?php<br />
&nbsp;&nbsp;&nbsp; </span><span class="keyword">function </span><span class="default">long_to_GET</span><span class="keyword">(){<br />
&nbsp;&nbsp; &nbsp; &nbsp;&nbsp; </span><span class="comment">/**<br />
&nbsp;&nbsp; &nbsp; &nbsp;&nbsp; * This function converts info.php/a/1/b/2/c?d=4 TO<br />
&nbsp;&nbsp; &nbsp; &nbsp;&nbsp; * Array ( [d] =&gt; 4 [a] =&gt; 1 [b] =&gt; 2 [c] =&gt; ) <br />
&nbsp;&nbsp; &nbsp; &nbsp;&nbsp; **/<br />
&nbsp;&nbsp; &nbsp; &nbsp;&nbsp; </span><span class="keyword">if(isset(</span><span class="default">$_SERVER</span><span class="keyword">[</span><span class="string">'PATH_INFO'</span><span class="keyword">]) &amp;&amp; </span><span class="default">$_SERVER</span><span class="keyword">[</span><span class="string">'PATH_INFO'</span><span class="keyword">] != </span><span class="string">''</span><span class="keyword">){<br />
&nbsp;&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; </span><span class="comment">//Split it out.<br />
&nbsp;&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; </span><span class="default">$tmp </span><span class="keyword">= </span><span class="default">explode</span><span class="keyword">(</span><span class="string">'/'</span><span class="keyword">,</span><span class="default">$_SERVER</span><span class="keyword">[</span><span class="string">'PATH_INFO'</span><span class="keyword">]);<br />
&nbsp;&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; </span><span class="comment">//Remove first empty item<br />
&nbsp;&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; </span><span class="keyword">unset(</span><span class="default">$tmp</span><span class="keyword">[</span><span class="default">0</span><span class="keyword">]);<br />
&nbsp;&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; </span><span class="comment">//Loop through and apend it into the $_GET superglobal.<br />
&nbsp;&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; </span><span class="keyword">for(</span><span class="default">$i</span><span class="keyword">=</span><span class="default">1</span><span class="keyword">;</span><span class="default">$i</span><span class="keyword">&lt;=</span><span class="default">count</span><span class="keyword">(</span><span class="default">$tmp</span><span class="keyword">);</span><span class="default">$i</span><span class="keyword">+=</span><span class="default">2</span><span class="keyword">){ </span><span class="default">$_GET</span><span class="keyword">[</span><span class="default">$tmp</span><span class="keyword">[</span><span class="default">$i</span><span class="keyword">]] = </span><span class="default">$tmp</span><span class="keyword">[</span><span class="default">$i</span><span class="keyword">+</span><span class="default">1</span><span class="keyword">];}<br />
&nbsp;&nbsp; &nbsp; &nbsp;&nbsp; }<br />
&nbsp;&nbsp;&nbsp; }<br />
</span><span class="default">?&gt;<br />
</span><br />
Its probably not the most efficient, but it does the job rather nicely.<br />
<br />
DD32</span>
</code>
    </div>
   </div>
  </div>
 <div class="foot"></div>
  <a name="30678""></a>
  <div class="note">
   <strong class="user">LouisGreen at pljg dot freeserve dot co dot uk</strong>
   <a href="#30678" class="date">25-Mar-2003 10:22</a>
   <div class="text">
    <div class="phpcode">
<code><span class="html">
It seems that when you wish to export a varible, you can do it as return $varible, return an array(), or globalise it. If you return something, information for that varible can only travel one way when the script is running, and that is out of the function. <br />
<br />
function fn() {<br />
&nbsp;&nbsp; $varible = "something";<br />
<br />
&nbsp; return $variable;<br />
}<br />
<br />
echo fn();<br />
OR<br />
$newvariable = fn();<br />
<br />
Although if global was used, it creates a pointer to a varible, whether it existed or not, and makes whatever is created in the function linked to that global pointer. So if the pointer was global $varible, and then you set a value to $varible, it would then be accessible in the global scope. But then what if you later on in the script redefine that global to equal something else. This means that whatever is put into the global array, the information that is set in the pointer, can be set at any point (overiden). Here is an example that might make this a little clearer:<br />
<br />
function fn1() {<br />
<br />
&nbsp;&nbsp; global $varible; // Pointer to the global array<br />
&nbsp;&nbsp; $varible = "something";<br />
}<br />
<br />
fn1();<br />
echo $varible; // Prints something<br />
$varible = "12345";<br />
echo $varible; // Prints 12345<br />
<br />
function fn2() {<br />
<br />
&nbsp;&nbsp; global $varible; // Pointer to the global array<br />
&nbsp;&nbsp; echo $varible;<br />
}<br />
<br />
fn2(); // echos $varible which contains "12345"<br />
<br />
Basically when accessing the global array, you can set it refer to something already defined or set it to something, (a pointer) such as varible you plan to create in the function, and later possibly over ride the pointer with something else.</span>
</code>
    </div>
   </div>
  </div>
 <div class="foot"></div>
  <a name="28614""></a>
  <div class="note">
   <strong class="user">lopez dot on dot the dot lists at yellowspace dot net</strong>
   <a href="#28614" class="date">17-Jan-2003 06:11</a>
   <div class="text">
    <div class="phpcode">
<code><span class="html">
- Security Issue and workaround - <br />
If You use "eval()" to execute code stored in a database or elsewhere, you might find this tip useful.<br />
<br />
Issue:<br />
By default, all superglobals are known in every function. <br />
Thus, if you eval database- or dynamically generated code (let's call it "potentially unsafe code"), it can use _all_ the values stored in _any_ superglobal. <br />
<br />
Workaround:<br />
Whenever you want to hide superglobals from use in evaluated code, wrap that eval() in an own function within which you unset() all the superglobals. The superglobals are not deleted by php in all scopes - just within that function. eg:<br />
<br />
function safeEval($evalcode) {<br />
&nbsp;&nbsp;&nbsp; unset($GLOBALS);<br />
&nbsp;&nbsp;&nbsp; unset($_ENV);<br />
&nbsp;&nbsp;&nbsp; // unset any other superglobal...<br />
&nbsp;&nbsp;&nbsp; return eval($evalcode);<br />
}<br />
<br />
(This example assumes that the eval returns something with 'return')<br />
<br />
In addition, by defining such a function outside classes, in the global scope, you'll make sure as well that the evaluated ('unsafe') code doesn't have access to the object variables ($this-&gt; ...).</span>
</code>
    </div>
   </div>
  </div>
 <div class="foot"></div>
</div>
</div>
</div></div></body></html>
