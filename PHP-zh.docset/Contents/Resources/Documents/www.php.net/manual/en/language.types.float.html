<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN" "http://www.w3.org/TR/html4/loose.dtd">
<html>
 <head>
  <meta http-equiv="content-type" content="text/html; CHARSET=gb2312">
  <title>Float 浮点型</title>
<link media="all" rel="stylesheet" type="text/css" href="styles/03e73060321a0a848018724a6c83de7f-theme-base.css" />
<link media="all" rel="stylesheet" type="text/css" href="styles/03e73060321a0a848018724a6c83de7f-theme-medium.css" />

  <meta http-equiv="X-UA-Compatible" content="IE=edge" />
  <link media="all" rel="stylesheet" type="text/css" href="style.css"/>
 </head>
 <body class="docs" class="docs"><div class="navbar navbar-fixed-top">
  <div class="navbar-inner clearfix">
    <ul class="nav" style="width: 100%">
      <li style="float: left;"><a href="language.types.integer.html">? Integer 整型</a></li>
      <li style="float: right;"><a href="language.types.string.html">String 字符串 ?</a></li>
    </ul>
  </div>
</div>
<div id="breadcrumbs" class="clearfix">
  <ul class="breadcrumbs-container">
    <li><a href="index.html">PHP Manual</a></li>
    <li><a href="language.types.html">类型</a></li>
    <li>Float 浮点型</li>
  </ul>
</div>
<div id="layout">
  <div id="layout-content"><div id="language.types.float" class="sect1">
 <h2 class="title">Float 浮点型</h2>

 <p class="para">
  浮点型（也叫浮点数 float，双精度数 double 或实数 real）可以用以下任一语法定义：
 </p>

 <div class="informalexample">
  <div class="example-contents">
<div class="phpcode"><code><span style="color: #000000"><span style="color: #0000BB">&lt;?php<br />$a </span><span style="color: #007700">= </span><span style="color: #0000BB">1.234</span><span style="color: #007700">; <br /></span><span style="color: #0000BB">$b </span><span style="color: #007700">= </span><span style="color: #0000BB">1.2e3</span><span style="color: #007700">; <br /></span><span style="color: #0000BB">$c </span><span style="color: #007700">= </span><span style="color: #0000BB">7E-10</span><span style="color: #007700">;<br /></span><span style="color: #0000BB">$d </span><span style="color: #007700">= </span><span style="color: #0000BB">1_234.567</span><span style="color: #007700">; </span><span style="color: #FF8000">// 从 PHP 7.4.0 开始支持<br /></span><span style="color: #0000BB">?&gt;</span></span></code></div>
  </div>

 </div>

 <p class="para">
  浮点数的形式表示（PHP 7.4.0 之前不支持下划线）：
 </p>

 <div class="informalexample">
  <div class="example-contents">
<div class="cdata"><pre>
LNUM          [0-9]+(_[0-9]+)*
DNUM ({LNUM}?&quot;.&quot;{LNUM}) | ({LNUM}&quot;.&quot;{LNUM}?)
EXPONENT_DNUM (({LNUM} | {DNUM}) [eE][+-]? {LNUM})
</pre></div>
  </div>

 </div>

 <p class="para">
  浮点数的字长和平台相关，尽管通常最大值是 1.8e308 并具有 14 位十进制数字的精度（64
  位 IEEE 格式）。
 </p>

 <div class="warning"><strong class="warning">Warning</strong>
  <h1 class="title">浮点数的精度</h1>

  <p class="para">
   浮点数的精度有限。尽管取决于系统，PHP 通常使用 IEEE 754
   双精度格式，则由于取整而导致的最大相对误差为
   1.11e-16。非基本数学运算可能会给出更大误差，并且要考虑到进行复合运算时的误差传递。
  </p>
  <p class="para">
   此外，以十进制能够精确表示的有理数如 <code class="literal">0.1</code> 或
   <code class="literal">0.7</code>，无论有多少尾数都不能被内部所使用的二进制精确表示，因此不能在不丢失一点点精度的情况下转换为二进制的格式。这就会造成混乱的结果：例如，<code class="literal">floor((0.1+0.7)*10)</code>
   通常会返回 <code class="literal">7</code> 而不是预期中的
   <code class="literal">8</code>，因为该结果内部的表示其实是类似
   <code class="literal">7.9999999999999991118...</code>。
  </p>

  <p class="para">
   所以永远不要相信浮点数结果精确到了最后一位，也永远不要比较两个浮点数是否相等。如果确实需要更高的精度，应该使用<a href="ref.bc.html" class="link">任意精度数学函数</a>或者 <a href="ref.gmp.html" class="link">gmp 函数</a>。
  </p>
  <p class="para">
   参见<a href="http://floating-point-gui.de/" class="link external" title="Link : http://floating-point-gui.de/">&raquo;&nbsp;浮点数指南</a>网页的简单解释。
  </p>
 </div>

 <div class="sect2" id="language.types.float.casting">
  <h3 class="title">转换为浮点数</h3>

  <div class="sect3" id="language.types.float.casting.from-string">
   <h4 class="title">从 string 转换</h4>

   <p class="simpara">
    如果 string 是 <a href="language.types.numeric-strings.html" class="link">numeric</a> 或者前导数字，
    则将它解析为相应的 float 值，否则将转换为零（<code class="literal">0</code>）。
   </p>
  </div>

  <div class="sect3" id="language.types.float.casting.from-other">
   <h4 class="title">从其他类型转换</h4>

   <p class="para">
    对于其它类型的值，其情况类似于先将值转换成 <span class="type"><a href="language.types.integer.html" class="type int">int</a></span>，然后再转换成 <span class="type"><a href="language.types.float.html" class="type float">float</a></span>。
    请参阅"<a href="language.types.integer.html#language.types.integer.casting" class="link">转换为整型</a>"一节以获取更多信息。
   </p>

   <blockquote class="note"><p><strong class="note">Note</strong>: 
    <p class="para">
     某些类型在转换成 <span class="type"><a href="language.types.integer.html" class="type int">int</a></span> 时有未定义行为，转换为 <span class="type"><a href="language.types.float.html" class="type float">float</a></span> 时也会如此。
    </p>
   </p></blockquote>
  </div>

 </div>
 <div class="sect2" id="language.types.float.comparison">
  <h3 class="title">比较浮点数</h3>

  <p class="para">
   如上述警告信息所言，由于内部表达方式的原因，比较两个浮点数是否相等是有问题的。不过还是有迂回的方法来比较浮点数值的。
  </p>

  <p class="para">
   要测试浮点数是否相等，要使用一个仅比该数值大一丁点的最小误差值。该值也被称为机器极小值（epsilon）或最小单元取整数，是计算中所能接受的最小的差别值。
  </p>
  
  <div class="informalexample">
   <p class="simpara">
    <var class="varname">$a</var> 和 <var class="varname">$b</var> 在小数点后五位精度内都是相等的。
   </p>
   <div class="example-contents">
<div class="phpcode"><code><span style="color: #000000"><span style="color: #0000BB">&lt;?php<br />$a </span><span style="color: #007700">= </span><span style="color: #0000BB">1.23456789</span><span style="color: #007700">;<br /></span><span style="color: #0000BB">$b </span><span style="color: #007700">= </span><span style="color: #0000BB">1.23456780</span><span style="color: #007700">;<br /></span><span style="color: #0000BB">$epsilon </span><span style="color: #007700">= </span><span style="color: #0000BB">0.00001</span><span style="color: #007700">;<br /><br />if(</span><span style="color: #0000BB">abs</span><span style="color: #007700">(</span><span style="color: #0000BB">$a</span><span style="color: #007700">-</span><span style="color: #0000BB">$b</span><span style="color: #007700">) &lt; </span><span style="color: #0000BB">$epsilon</span><span style="color: #007700">) {<br />    echo </span><span style="color: #DD0000">"true"</span><span style="color: #007700">;<br />}<br /></span><span style="color: #0000BB">?&gt;</span></span></code></div>
   </div>

  </div>
 </div>
 
 <div class="sect2" id="language.types.float.nan">
  <h3 class="title">NaN</h3>
  <p class="para">
   某些数学运算会产生一个由常量 <strong><code><a href="math.constants.html#constant.nan">NAN</a></code></strong>
   所代表的结果。此结果代表着一个在浮点数运算中未定义或不可表述的值。任何拿此值与其它任何值（除了  <strong><code><a href="reserved.constants.html#constant.true">true</a></code></strong>）进行的松散或严格比较的结果都是
   <strong><code><a href="reserved.constants.html#constant.false">false</a></code></strong>。
  </p>
  <p class="para">
   由于 <strong><code><a href="math.constants.html#constant.nan">NAN</a></code></strong> 代表着任何不同值，不应拿
   <strong><code><a href="math.constants.html#constant.nan">NAN</a></code></strong> 去和其它值进行比较，包括其自身，应该用
   <span class="function"><a href="function.is-nan.html" class="function">is_nan()</a></span> 来检查。
  </p>
 </div>
</div><div id="usernotes">
 <div class="head">
  <h3 class="title">User Contributed Notes</h3>
 </div>
<div id="allnotes">  <a name="128781""></a>
  <div class="note">
   <strong class="user">251701981 at qq dot com</strong>
   <a href="#128781" class="date">05-Aug-2023 03:58</a>
   <div class="text">
    <div class="phpcode">
<code><span class="html">
<span class="default">&lt;?php<br />
<br />
</span><span class="comment">//Please consider the following code<br />
&nbsp; </span><span class="default">printf</span><span class="keyword">(</span><span class="string">"%.53f\n"</span><span class="keyword">,</span><span class="default">0.7</span><span class="keyword">+</span><span class="default">0.1</span><span class="keyword">);&nbsp; </span><span class="comment">// 0.79999999999999993338661852249060757458209991455078125<br />
<br />
&nbsp;&nbsp; &nbsp; &nbsp; </span><span class="default">var_dump</span><span class="keyword">(</span><span class="default">0.7</span><span class="keyword">+</span><span class="default">0.1</span><span class="keyword">);&nbsp;&nbsp; </span><span class="comment">// float(0.8)<br />
<br />
&nbsp;&nbsp; &nbsp; &nbsp; </span><span class="default">var_dump</span><span class="keyword">(</span><span class="default">0.799999999999999</span><span class="keyword">);&nbsp; </span><span class="comment">//float(0.8)<br />
<br />
&nbsp;&nbsp; &nbsp; &nbsp; </span><span class="default">var_dump</span><span class="keyword">(</span><span class="default">0.7999999</span><span class="keyword">); </span><span class="comment">// float(0.7999999)<br />
<br />
//Conclusion: PHP can support up to 53 decimal places, but in some output functions such as var_ Dump, when outputting decimals exceeding 14 places, will round off the 15th place, which causes significant misleading<br />
//experimental environment：linux x64，php7.2.x</span>
</span>
</code>
    </div>
   </div>
  </div>
 <div class="foot"></div>
  <a name="120766""></a>
  <div class="note">
   <strong class="user">lwiwala at gmail dot com</strong>
   <a href="#120766" class="date">07-Mar-2017 03:49</a>
   <div class="text">
    <div class="phpcode">
<code><span class="html">
To compare two numbers use:<br />
<br />
$epsilon = 1e-6;<br />
<br />
if(abs($firstNumber-$secondNumber) &lt; $epsilon){<br />
&nbsp;&nbsp; // equals<br />
}</span>
</code>
    </div>
   </div>
  </div>
 <div class="foot"></div>
  <a name="113703""></a>
  <div class="note">
   <strong class="user">catalin dot luntraru at gmail dot com</strong>
   <a href="#113703" class="date">18-Nov-2013 03:44</a>
   <div class="text">
    <div class="phpcode">
<code><span class="html">
$x = 8 - 6.4;&nbsp; // which is equal to 1.6<br />
$y = 1.6;<br />
var_dump($x == $y); // is not true<br />
<br />
PHP thinks that 1.6 (coming from a difference) is not equal to 1.6. To make it work, use round()<br />
<br />
var_dump(round($x, 2) == round($y, 2)); // this is true<br />
<br />
This happens probably because $x is not really 1.6, but 1.599999.. and var_dump shows it to you as being 1.6.</span>
</code>
    </div>
   </div>
  </div>
 <div class="foot"></div>
  <a name="103209""></a>
  <div class="note">
   <strong class="user">zelko at mojeime dot com</strong>
   <a href="#103209" class="date">31-Mar-2011 01:02</a>
   <div class="text">
    <div class="phpcode">
<code><span class="html">
<span class="default">&lt;?php<br />
&nbsp;&nbsp; $binarydata32 </span><span class="keyword">= </span><span class="default">pack</span><span class="keyword">(</span><span class="string">'H*'</span><span class="keyword">,</span><span class="string">'00000000'</span><span class="keyword">);<br />
&nbsp;&nbsp; </span><span class="default">$float32 </span><span class="keyword">= </span><span class="default">unpack</span><span class="keyword">(</span><span class="string">"f"</span><span class="keyword">, </span><span class="default">$binarydata32</span><span class="keyword">); </span><span class="comment">// 0.0<br />
<br />
&nbsp;&nbsp; </span><span class="default">$binarydata64 </span><span class="keyword">= </span><span class="default">pack</span><span class="keyword">(</span><span class="string">'H*'</span><span class="keyword">,</span><span class="string">'0000000000000000'</span><span class="keyword">);<br />
&nbsp;&nbsp; </span><span class="default">$float64 </span><span class="keyword">= </span><span class="default">unpack</span><span class="keyword">(</span><span class="string">"d"</span><span class="keyword">, </span><span class="default">$binarydata64</span><span class="keyword">); </span><span class="comment">// 0.0<br />
</span><span class="default">?&gt;<br />
</span><br />
I get 0 both for 32-bit and 64-bit numbers.<br />
<br />
But, please don't use your own "functions" to "convert" from float to binary and vice versa. Looping performance in PHP is horrible. Using pack/unpack you use processor's encoding, which is always correct. In C++ you can access the same 32/64 data as either float/double or 32/64 bit integer. No "conversions".<br />
<br />
To get binary encoding:<br />
<span class="default">&lt;?php<br />
&nbsp;&nbsp; $float32 </span><span class="keyword">= </span><span class="default">pack</span><span class="keyword">(</span><span class="string">"f"</span><span class="keyword">, </span><span class="default">5300231</span><span class="keyword">);<br />
&nbsp;&nbsp; </span><span class="default">$binarydata32 </span><span class="keyword">=</span><span class="default">unpack</span><span class="keyword">(</span><span class="string">'H*'</span><span class="keyword">,</span><span class="default">$float32</span><span class="keyword">); </span><span class="comment">//"0EC0A14A"<br />
<br />
&nbsp;&nbsp; </span><span class="default">$float64 </span><span class="keyword">= </span><span class="default">pack</span><span class="keyword">(</span><span class="string">"d"</span><span class="keyword">, </span><span class="default">5300231</span><span class="keyword">);<br />
&nbsp;&nbsp; </span><span class="default">$binarydata64 </span><span class="keyword">=</span><span class="default">unpack</span><span class="keyword">(</span><span class="string">'H*'</span><span class="keyword">,</span><span class="default">$float64</span><span class="keyword">); </span><span class="comment">//"000000C001385441"<br />
</span><span class="default">?&gt;<br />
</span><br />
And my example from half a year ago:<br />
<span class="default">&lt;?php<br />
&nbsp;&nbsp;&nbsp; $binarydata32 </span><span class="keyword">= </span><span class="default">pack</span><span class="keyword">(</span><span class="string">'H*'</span><span class="keyword">,</span><span class="string">'0EC0A14A'</span><span class="keyword">);<br />
&nbsp;&nbsp;&nbsp; </span><span class="default">$float32 </span><span class="keyword">= </span><span class="default">unpack</span><span class="keyword">(</span><span class="string">"f"</span><span class="keyword">, </span><span class="default">$binarydata32</span><span class="keyword">); </span><span class="comment">// 5300231<br />
&nbsp;&nbsp; <br />
&nbsp;&nbsp;&nbsp; </span><span class="default">$binarydata64 </span><span class="keyword">= </span><span class="default">pack</span><span class="keyword">(</span><span class="string">'H*'</span><span class="keyword">,</span><span class="string">'000000C001385441'</span><span class="keyword">);<br />
&nbsp;&nbsp;&nbsp; </span><span class="default">$float64 </span><span class="keyword">= </span><span class="default">unpack</span><span class="keyword">(</span><span class="string">"d"</span><span class="keyword">, </span><span class="default">$binarydata64</span><span class="keyword">); </span><span class="comment">// 5300231<br />
</span><span class="default">?&gt;<br />
</span><br />
And please mind the Big and Little endian boys...</span>
</code>
    </div>
   </div>
  </div>
 <div class="foot"></div>
  <a name="98216""></a>
  <div class="note">
   <strong class="user">magicaltux at php dot net</strong>
   <a href="#98216" class="date">01-Jun-2010 07:02</a>
   <div class="text">
    <div class="phpcode">
<code><span class="html">
In some cases you may want to get the maximum value for a float without getting "INF".<br />
<br />
var_dump(1.8e308); will usually show: float(INF)<br />
<br />
I wrote a tiny function that will iterate in order to find the biggest non-infinite float value. It comes with a configurable multiplicator and affine values so you can share more CPU to get a more accurate estimate.<br />
<br />
I haven't seen better values with more affine, but well, the possibility is here so if you really thing it's worth the cpu time, just try to affine more.<br />
<br />
Best results seems to be with mul=2/affine=1. You can play with the values and see what you get. The good thing is this method will work on any system.<br />
<br />
<span class="default">&lt;?php<br />
&nbsp; </span><span class="keyword">function </span><span class="default">float_max</span><span class="keyword">(</span><span class="default">$mul </span><span class="keyword">= </span><span class="default">2</span><span class="keyword">, </span><span class="default">$affine </span><span class="keyword">= </span><span class="default">1</span><span class="keyword">) {<br />
&nbsp;&nbsp;&nbsp; </span><span class="default">$max </span><span class="keyword">= </span><span class="default">1</span><span class="keyword">; </span><span class="default">$omax </span><span class="keyword">= </span><span class="default">0</span><span class="keyword">;<br />
&nbsp;&nbsp;&nbsp; while((string)</span><span class="default">$max </span><span class="keyword">!= </span><span class="string">'INF'</span><span class="keyword">) { </span><span class="default">$omax </span><span class="keyword">= </span><span class="default">$max</span><span class="keyword">; </span><span class="default">$max </span><span class="keyword">*= </span><span class="default">$mul</span><span class="keyword">; }<br />
<br />
&nbsp;&nbsp;&nbsp; for(</span><span class="default">$i </span><span class="keyword">= </span><span class="default">0</span><span class="keyword">; </span><span class="default">$i </span><span class="keyword">&lt; </span><span class="default">$affine</span><span class="keyword">; </span><span class="default">$i</span><span class="keyword">++) {<br />
&nbsp;&nbsp; &nbsp;&nbsp; </span><span class="default">$pmax </span><span class="keyword">= </span><span class="default">1</span><span class="keyword">; </span><span class="default">$max </span><span class="keyword">= </span><span class="default">$omax</span><span class="keyword">;<br />
&nbsp;&nbsp; &nbsp;&nbsp; while((string)</span><span class="default">$max </span><span class="keyword">!= </span><span class="string">'INF'</span><span class="keyword">) {<br />
&nbsp;&nbsp; &nbsp; &nbsp;&nbsp; </span><span class="default">$omax </span><span class="keyword">= </span><span class="default">$max</span><span class="keyword">;<br />
&nbsp;&nbsp; &nbsp; &nbsp;&nbsp; </span><span class="default">$max </span><span class="keyword">+= </span><span class="default">$pmax</span><span class="keyword">;<br />
&nbsp;&nbsp; &nbsp; &nbsp;&nbsp; </span><span class="default">$pmax </span><span class="keyword">*= </span><span class="default">$mul</span><span class="keyword">;<br />
&nbsp;&nbsp; &nbsp;&nbsp; }<br />
&nbsp;&nbsp;&nbsp; }<br />
&nbsp;&nbsp;&nbsp; return </span><span class="default">$omax</span><span class="keyword">;<br />
&nbsp; }<br />
</span><span class="default">?&gt;</span>
</span>
</code>
    </div>
   </div>
  </div>
 <div class="foot"></div>
  <a name="58824""></a>
  <div class="note">
   <strong class="user">Luzian</strong>
   <a href="#58824" class="date">17-Nov-2005 12:03</a>
   <div class="text">
    <div class="phpcode">
<code><span class="html">
Be careful when using float values in strings that are used as code later, for example when generating JavaScript code or SQL statements. The float is actually formatted according to the browser's locale setting, which means that "0.23" will result in "0,23". Imagine something like this:<br />
<br />
$x = 0.23;<br />
$js = "var foo = doBar($x);";<br />
print $js;<br />
<br />
This would result in a different result for users with some locales. On most systems, this would print:<br />
<br />
var foo = doBar(0.23);<br />
<br />
but when for example a user from Germany arrives, it would be different:<br />
<br />
var foo = doBar(0,23);<br />
<br />
which is obviously a different call to the function. JavaScript won't state an error, additional arguments are discarded without notice, but the function doBar(a) would get 0 as parameter. Similar problems could arise anywhere else (SQL, any string used as code somewhere else). The problem persists, if you use the "." operator instead of evaluating the variable in the string.<br />
<br />
So if you REALLY need to be sure to have the string correctly formatted, use number_format() to do it!</span>
</code>
    </div>
   </div>
  </div>
 <div class="foot"></div>
  <a name="54494""></a>
  <div class="note">
   <strong class="user">rick at ninjafoo dot com</strong>
   <a href="#54494" class="date">06-Jul-2005 01:04</a>
   <div class="text">
    <div class="phpcode">
<code><span class="html">
Concider the following:<br />
<br />
(19.6*100) != 1960&nbsp; <br />
<br />
echo gettype(19.6*100) returns 'double', However even ..... <br />
<br />
(19.6*100) !== (double)1960 <br />
<br />
19.6*100 cannot be compaired to anything without manually <br />
casting it as something else first. <br />
<br />
(string)(19.6*100) == 1960<br />
<br />
Rule of thumb, if it has a decimal point, use the BCMath functions.</span>
</code>
    </div>
   </div>
  </div>
 <div class="foot"></div>
  <a name="44692""></a>
  <div class="note">
   <strong class="user">feline at NOSPAM dot penguin dot servehttp dot com</strong>
   <a href="#44692" class="date">12-Aug-2004 06:36</a>
   <div class="text">
    <div class="phpcode">
<code><span class="html">
General computing hint: If you're keeping track of money, do yourself and your users the favor of handling everything internally in cents and do as much math as you can in integers. Store values in cents if at all possible. Add and subtract in cents. At every operation that wii involve floats, ask yourself "what will happen in the real world if I get a fraction of a cent here" and if the answer is that this operation will generate a transaction in integer cents, do not try to carry fictional fractional accuracy that will only screw things up later.</span>
</code>
    </div>
   </div>
  </div>
 <div class="foot"></div>
  <a name="31622""></a>
  <div class="note">
   <strong class="user">james dot cridland at virginradio dot co dot uk</strong>
   <a href="#31622" class="date">28-Apr-2003 07:44</a>
   <div class="text">
    <div class="phpcode">
<code><span class="html">
The 'floating point precision' box in practice means:<br />
<br />
&lt;? echo (69.1-floor(69.1)); ?&gt;<br />
Think this'll return 0.1?<br />
It doesn't - it returns 0.099999999999994<br />
<br />
&lt;? echo round((69.1-floor(69.1))); ?&gt;<br />
This returns 0.1 and is the workaround we use.<br />
<br />
Note that<br />
&lt;? echo (4.1-floor(4.1)); ?&gt;<br />
*does* return 0.1 - so if you, like us, test this with low numbers, you won't, like us, understand why all of a sudden your script stops working, until you spend a lot of time, like us, debugging it.<br />
<br />
So, that's all lovely then.</span>
</code>
    </div>
   </div>
  </div>
 <div class="foot"></div>
  <a name="30071""></a>
  <div class="note">
   <strong class="user">backov at spotbrokers-nospamplz dot com</strong>
   <a href="#30071" class="date">05-Mar-2003 01:16</a>
   <div class="text">
    <div class="phpcode">
<code><span class="html">
I'd like to point out a "feature" of PHP's floating point support that isn't made clear anywhere here, and was driving me insane.
<br />

<br />
This test (where var_dump says that $a=0.1 and $b=0.1)
<br />

<br />
if ($a&gt;=$b) echo "blah!";
<br />

<br />
Will fail in some cases due to hidden precision (standard C problem, that PHP docs make no mention of, so I assumed they had gotten rid of it). I should point out that I originally thought this was an issue with the floats being stored as strings, so I forced them to be floats and they still didn't get evaluated properly (probably 2 different problems there).
<br />

<br />
To fix, I had to do this horrible kludge (the equivelant of anyway):
<br />

<br />
if (round($a,3)&gt;=round($b,3)) echo "blah!";
<br />

<br />
THIS works. Obviously even though var_dump says the variables are identical, and they SHOULD BE identical (started at 0.01 and added 0.001 repeatedly), they're not. There's some hidden precision there that was making me tear my hair out. Perhaps this should be added to the documentation?</span>
</code>
    </div>
   </div>
  </div>
 <div class="foot"></div>
  <a name="29170""></a>
  <div class="note">
   <strong class="user">www.sarioz.com</strong>
   <a href="#29170" class="date">04-Feb-2003 10:49</a>
   <div class="text">
    <div class="phpcode">
<code><span class="html">
just a comment on something the "Floating point precision" inset, which goes: "This is related to .... 0.3333333."<br />
<br />
While the author probably knows what they are talking about, this loss of precision has nothing to do with decimal notation, it has to do with representation as a floating-point binary in a finite register, such as while 0.8 terminates in decimal, it is the repeating 0.110011001100... in binary, which is truncated.&nbsp; 0.1 and 0.7 are also non-terminating in binary, so they are also truncated, and the sum of these truncated numbers does not add up to the truncated binary representation of 0.8 (which is why (floor)(0.8*10) yields a different, more intuitive, result).&nbsp; However, since 2 is a factor of 10, any number that terminates in binary also terminates in decimal.</span>
</code>
    </div>
   </div>
  </div>
 <div class="foot"></div>
</div>
</div>
</div></div></body></html>
