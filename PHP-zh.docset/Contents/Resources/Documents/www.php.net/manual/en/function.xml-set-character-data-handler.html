<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN" "http://www.w3.org/TR/html4/loose.dtd">
<html>
 <head>
  <meta http-equiv="content-type" content="text/html; CHARSET=gb2312">
  <title>建立字符数据处理器</title>
<link media="all" rel="stylesheet" type="text/css" href="styles/03e73060321a0a848018724a6c83de7f-theme-base.css" />
<link media="all" rel="stylesheet" type="text/css" href="styles/03e73060321a0a848018724a6c83de7f-theme-medium.css" />

  <meta http-equiv="X-UA-Compatible" content="IE=edge" />
  <link media="all" rel="stylesheet" type="text/css" href="style.css"/>
 </head>
 <body class="docs" class="docs"><div class="navbar navbar-fixed-top">
  <div class="navbar-inner clearfix">
    <ul class="nav" style="width: 100%">
      <li style="float: left;"><a href="function.xml-parser-set-option.html">? xml_parser_set_option</a></li>
      <li style="float: right;"><a href="function.xml-set-default-handler.html">xml_set_default_handler ?</a></li>
    </ul>
  </div>
</div>
<div id="breadcrumbs" class="clearfix">
  <ul class="breadcrumbs-container">
    <li><a href="index.html">PHP Manual</a></li>
    <li><a href="ref.xml.html">XML 解析器函数</a></li>
    <li>建立字符数据处理器</li>
  </ul>
</div>
<div id="layout">
  <div id="layout-content"><div id="function.xml-set-character-data-handler" class="refentry">
 <div class="refnamediv">
  <h1 class="refname">xml_set_character_data_handler</h1>
  <p class="verinfo">(PHP 4, PHP 5, PHP 7, PHP 8)</p><p class="refpurpose"><span class="refname">xml_set_character_data_handler</span> &mdash; <span class="dc-title">建立字符数据处理器</span></p>

 </div>
   
 <div class="refsect1 description" id="refsect1-function.xml-set-character-data-handler-description">
  <h3 class="title">说明</h3>
  <div class="methodsynopsis dc-description">
   <span class="methodname"><strong>xml_set_character_data_handler</strong></span>(<span class="methodparam"><span class="type"><a href="class.xmlparser.html" class="type XMLParser">XMLParser</a></span> <code class="parameter">$parser</code></span>, <span class="methodparam"><span class="type"><a href="language.types.callable.html" class="type callable">callable</a></span> <code class="parameter">$handler</code></span>): <span class="type"><a href="language.types.value.html" class="type true">true</a></span></div>

  <p class="para rdfs-comment">
   为 <code class="parameter">parser</code> 变量指向的 XML 解析器指定字符数据处理函数。
  </p>
 </div>


 <div class="refsect1 parameters" id="refsect1-function.xml-set-character-data-handler-parameters">
  <h3 class="title">参数</h3>
  <p class="para">
   <dl>
    
 <dt><code class="parameter">parser</code></dt>
 <dd>
  <p class="para">
   XML 解析器。
  </p>
 </dd>

    
     <dt><code class="parameter">handler</code></dt>
     <dd>
      <p class="para">
 如果传递 <strong><code><a href="reserved.constants.html#constant.null">null</a></code></strong> 或空字符串，处理程序将重置为其默认状态。
</p>
<p class="para">
 如果 <code class="parameter">handler</code> 是 <span class="type"><a href="language.types.callable.html" class="type callable">callable</a></span>，设置的 callable 将作为处理程序。
</p>
<p class="para">
 如果 <code class="parameter">handler</code> 是 <span class="type"><a href="language.types.string.html" class="type string">string</a></span>，它可以是 <span class="function"><a href="function.xml-set-object.html" class="function">xml_set_object()</a></span>
 设置的对象的方法名称。
</p>
      <p class="para">
       处理程序的签名必须是：
       <div class="methodsynopsis dc-description">
        <span class="methodname"><span class="replaceable">handler</span></span>(<span class="methodparam"><span class="type"><a href="class.xmlparser.html" class="type XMLParser">XMLParser</a></span> <code class="parameter">$parser</code></span>, <span class="methodparam"><span class="type"><a href="language.types.string.html" class="type string">string</a></span> <code class="parameter">$data</code></span>): <span class="type"><a href="language.types.void.html" class="type void">void</a></span></div>

       <dl>
        
 <dt><code class="parameter">parser</code></dt>
 <dd>
  <span class="simpara">
   XML 解析器调用的处理程序。
  </span>
 </dd>

        
         <dt><code class="parameter">data</code></dt>
         <dd>
          <span class="simpara">
           字符串格式的字符数据。
          </span>
         </dd>
        
       </dl>
      </p>
      <p class="para">
       XML 文档的每段文字都会调用字符数据处理程序。可以在每个片段内多次调用（比如非 ASCII 字符串）。
      </p>
     </dd>
    
   </dl>
  </p>
 </div>


 <div class="refsect1 returnvalues" id="refsect1-function.xml-set-character-data-handler-returnvalues">
  <h3 class="title">返回值</h3>
  <p class="para">
   总是返回 <strong><code><a href="reserved.constants.html#constant.true">true</a></code></strong>。
  </p>
 </div>


 <div class="refsect1 changelog" id="refsect1-function.xml-set-character-data-handler-changelog">
  <h3 class="title">更新日志</h3>
  <table class="doctable informaltable">
   
    <thead>
     <tr>
      <th>版本</th>
      <th>说明</th>
     </tr>

    </thead>

    <tbody class="tbody">
      <tr>
 <td>8.0.0</td>
 <td>
  <code class="parameter">parser</code> 现在接受 <span class="classname"><a href="class.xmlparser.html" class="classname">XMLParser</a></span> 实例；之前接受有效的 <code class="literal">xml</code> <span class="type"><a href="language.types.resource.html" class="type resource">resource</a></span>。
 </td>
</tr>

    </tbody>
   
  </table>

 </div>


</div><div id="usernotes">
 <div class="head">
  <h3 class="title">User Contributed Notes</h3>
 </div>
<div id="allnotes">  <a name="85415""></a>
  <div class="note">
   <strong class="user">jhill at live dot com</strong>
   <a href="#85415" class="date">28-Aug-2008 07:11</a>
   <div class="text">
    <div class="phpcode">
<code><span class="html">
To detect that concatenation of data is taking place, you can keep track of whether the last function call was to the data processing function.
<br />
e.g. using $this-&gt;inside_data variable below:
<br />

<br />
<span class="default">&lt;?php
<br />
xml_set_element_handler</span><span class="keyword">(</span><span class="default">$this</span><span class="keyword">-&gt;</span><span class="default">parser</span><span class="keyword">, </span><span class="string">"start_tag"</span><span class="keyword">, </span><span class="string">"end_tag"</span><span class="keyword">);
<br />
</span><span class="default">xml_set_character_data_handler</span><span class="keyword">(</span><span class="default">$this</span><span class="keyword">-&gt;</span><span class="default">parser</span><span class="keyword">, </span><span class="string">"contents"</span><span class="keyword">);
<br />

<br />
protected function </span><span class="default">contents</span><span class="keyword">(</span><span class="default">$parser</span><span class="keyword">, </span><span class="default">$data</span><span class="keyword">)
<br />
{
<br />
&nbsp;&nbsp;&nbsp; switch (</span><span class="default">$this</span><span class="keyword">-&gt;</span><span class="default">current_tag</span><span class="keyword">) {
<br />
&nbsp;&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; case </span><span class="string">"name"</span><span class="keyword">:
<br />
&nbsp;&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; if (</span><span class="default">$this</span><span class="keyword">-&gt;</span><span class="default">inside_data</span><span class="keyword">)
<br />
&nbsp;&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; </span><span class="default">$this</span><span class="keyword">-&gt;</span><span class="default">name </span><span class="keyword">.= </span><span class="default">$data</span><span class="keyword">; </span><span class="comment">// need to concatenate data
<br />
&nbsp;&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; </span><span class="keyword">else
<br />
&nbsp;&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; </span><span class="default">$this</span><span class="keyword">-&gt;</span><span class="default">name </span><span class="keyword">= </span><span class="default">$data</span><span class="keyword">;
<br />
&nbsp;&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; break;
<br />
&nbsp;&nbsp; &nbsp; &nbsp; &nbsp; ...
<br />
&nbsp;&nbsp;&nbsp; }
<br />
&nbsp;&nbsp;&nbsp; </span><span class="default">$this</span><span class="keyword">-&gt;</span><span class="default">inside_data </span><span class="keyword">= </span><span class="default">true</span><span class="keyword">;
<br />
}
<br />

<br />
protected function </span><span class="default">start_tag</span><span class="keyword">(</span><span class="default">$parser</span><span class="keyword">, </span><span class="default">$name</span><span class="keyword">)
<br />
{
<br />
&nbsp;&nbsp;&nbsp; </span><span class="default">$this</span><span class="keyword">-&gt;</span><span class="default">current_tag </span><span class="keyword">= </span><span class="default">$name</span><span class="keyword">;
<br />
&nbsp;&nbsp;&nbsp; </span><span class="default">$this</span><span class="keyword">-&gt;</span><span class="default">inside_data </span><span class="keyword">= </span><span class="default">false</span><span class="keyword">;
<br />
}
<br />
&nbsp;&nbsp; &nbsp; &nbsp;&nbsp; 
<br />
protected function </span><span class="default">end_tag</span><span class="keyword">() {
<br />
&nbsp;&nbsp;&nbsp; </span><span class="default">$this</span><span class="keyword">-&gt;</span><span class="default">current_tag </span><span class="keyword">= </span><span class="string">''</span><span class="keyword">;
<br />
&nbsp;&nbsp;&nbsp; </span><span class="default">$this</span><span class="keyword">-&gt;</span><span class="default">inside_data </span><span class="keyword">= </span><span class="default">false</span><span class="keyword">;
<br />
}
<br />
</span><span class="default">?&gt;</span>
</span>
</code>
    </div>
   </div>
  </div>
 <div class="foot"></div>
  <a name="60326""></a>
  <div class="note">
   <strong class="user">unspammable-iain at iaindooley dot com</strong>
   <a href="#60326" class="date">03-Jan-2006 01:41</a>
   <div class="text">
    <div class="phpcode">
<code><span class="html">
re: jason at omegavortex dot com below, another way to deal with whitespace issues is:<br />
<br />
&nbsp;&nbsp; &nbsp; &nbsp;&nbsp; function charData($parser,$data)<br />
&nbsp;&nbsp; &nbsp; &nbsp;&nbsp; {<br />
&nbsp;&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; $char_data = trim($data);<br />
<br />
&nbsp;&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; if($char_data)<br />
&nbsp;&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; $char_data = preg_replace('/&nbsp; */',' ',$data);<br />
<br />
&nbsp;&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; $this-&gt;cdata .= $char_data;<br />
&nbsp;&nbsp; &nbsp; &nbsp;&nbsp; }<br />
<br />
This means that:<br />
<br />
&nbsp;&nbsp;&nbsp; &lt;p&gt;here is my text &lt;a href="something"&gt;my text&lt;/a&gt; <br />
&nbsp;&nbsp;&nbsp; and here is some more after some spaces at the<br />
&nbsp;&nbsp;&nbsp; beginning of the line&lt;/p&gt;<br />
<br />
comes out properly. You could do further replacements if you want to deal with tabs in your files. i only ever use spaces. if you only use trim() then you would lose the space before the &lt;a&gt; tag above, but trim() is a good way to check for completely empty char data, then just replace more than one space with a single space. this will preserve a single space at the beginning and end of the cdata.</span>
</code>
    </div>
   </div>
  </div>
 <div class="foot"></div>
  <a name="55527""></a>
  <div class="note">
   <strong class="user">ben at removethis emediastudios dotcom</strong>
   <a href="#55527" class="date">05-Aug-2005 03:53</a>
   <div class="text">
    <div class="phpcode">
<code><span class="html">
I too love the undocumented "splitting" functionality :-p.<br />
<br />
Rather than concatinating the data based on whether or not the current tag name has changed from the previous tag name I suggest always concatinating like the following with the $catData variable being unset in the endElement function:<br />
<br />
<span class="default">&lt;?php<br />
<br />
</span><span class="keyword">function </span><span class="default">endElement </span><span class="keyword">(</span><span class="default">$parser</span><span class="keyword">, </span><span class="default">$data</span><span class="keyword">) {<br />
&nbsp; global </span><span class="default">$catData</span><span class="keyword">;<br />
<br />
&nbsp; </span><span class="comment">// Because we are at an element end we know any splitting is finished<br />
&nbsp; </span><span class="keyword">unset(</span><span class="default">$GLOBALS</span><span class="keyword">[</span><span class="string">'catData'</span><span class="keyword">]);<br />
}<br />
<br />
function </span><span class="default">characterData </span><span class="keyword">(</span><span class="default">$parser</span><span class="keyword">, </span><span class="default">$data</span><span class="keyword">) {<br />
&nbsp; global </span><span class="default">$catData</span><span class="keyword">;<br />
<br />
&nbsp; </span><span class="comment">// Concatinate data in case splitting is taking place<br />
&nbsp; </span><span class="default">$catData</span><span class="keyword">.=</span><span class="default">$data</span><span class="keyword">;<br />
<br />
}<br />
<br />
</span><span class="default">?&gt;<br />
</span><br />
This got me around a problem with data like the following where, because characterData is not called for empty tags, the previous and current tag names were the same even though splitting was not taking place.<br />
<br />
&lt;companydept&gt;<br />
&lt;companydeptID&gt;&lt;/companydeptID&gt;<br />
&lt;companyID&gt;1&lt;/companyID&gt;<br />
&lt;companydeptName&gt;&lt;/companydeptName&gt;<br />
&lt;/companydept&gt;<br />
&lt;companydept&gt;<br />
&lt;companydeptID&gt;&lt;/companydeptID&gt;<br />
&lt;companyID&gt;2&lt;/companyID&gt;<br />
&lt;companydeptName&gt;&lt;/companydeptName&gt;<br />
&lt;/companydept&gt;<br />
&lt;companydept&gt;<br />
&lt;companydeptID&gt;&lt;/companydeptID&gt;<br />
&lt;companyID&gt;3&lt;/companyID&gt;<br />
&lt;companydeptName&gt;&lt;/companydeptName&gt;<br />
&lt;/companydept&gt;</span>
</code>
    </div>
   </div>
  </div>
 <div class="foot"></div>
  <a name="52233""></a>
  <div class="note">
   <strong class="user">yaroukh at email dot cz</strong>
   <a href="#52233" class="date">25-Apr-2005 08:51</a>
   <div class="text">
    <div class="phpcode">
<code><span class="html">
It would be nice if someone could complete documentation of this function. I think that the "splitting" behaviour should (at least) be mentioned within the documentation, if not explained (please!). I'm not quite sure whether the cut comes after each 1024bytes/chars of data.<br />
<br />
My experience looks as follows:<br />
[xmlFile]<br />
...<br />
&nbsp;&nbsp;&nbsp; &lt;label&gt;slo|?ka&lt;/label&gt;<br />
&nbsp;&nbsp;&nbsp; &lt;comment&gt;koment|?&amp;#345; slo?ky&lt;/comment&gt;<br />
...<br />
[/xmlFile]<br />
(Places where the character-data got splitted are marked with pipes. Plus there was latin small letter 'r' with caron instead of &amp;#345;.)<br />
<br />
Since the splitting is not mentioned in documentation one could assume that it is a bug; especially when you work with UTF-8 and the cuts come right before some special characters.<br />
(Should the concatenating of $cData be considered to be the proper &amp; 'final' way of processing character-data?)<br />
<br />
Also I'd suggest to add another line in "Description" when fc has an alternate usage (instead of hiding it within the "Note" :o); in this particular case I'd prefer this:<br />
<br />
Description:<br />
bool xml_set_character_data_handler ( resource parser, callback handler )<br />
bool xml_set_character_data_handler ( resource parser, object reference, method name )<br />
<br />
... there are dozens of functions ofcourse where documentation works this way (I mean not mentioning the alternate usage in the "Description" part).<br />
<br />
Have a nice day<br />
&nbsp; Yaroukh</span>
</code>
    </div>
   </div>
  </div>
 <div class="foot"></div>
  <a name="49943""></a>
  <div class="note">
   <strong class="user">flobee</strong>
   <a href="#49943" class="date">12-Feb-2005 09:53</a>
   <div class="text">
    <div class="phpcode">
<code><span class="html">
re. to Philippe Marc , and&nbsp; karuna_gadde examples<br />
<br />
i found out that the xml_set_character_data_handler call back&nbsp; function can be called more often for the same element in particular the content is just a few chars long (happen on windows)<br />
<br />
so a check up can give you the answer an may be for long strings too.<br />
eg:<br />
<span class="default">&lt;?php<br />
xml_set_character_data_handler</span><span class="keyword">(</span><span class="default">$this</span><span class="keyword">-&gt;</span><span class="default">parser</span><span class="keyword">, </span><span class="string">"cdata"</span><span class="keyword">);<br />
</span><span class="comment">//...<br />
</span><span class="keyword">function </span><span class="default">cdata</span><span class="keyword">(</span><span class="default">$parser</span><span class="keyword">, </span><span class="default">$cdata</span><span class="keyword">) {<br />
</span><span class="comment">// ...<br />
</span><span class="keyword">if(isset(</span><span class="default">$this</span><span class="keyword">-&gt;</span><span class="default">data</span><span class="keyword">[</span><span class="default">$this</span><span class="keyword">-&gt;</span><span class="default">currentItem</span><span class="keyword">][</span><span class="default">$this</span><span class="keyword">-&gt;</span><span class="default">currentField</span><span class="keyword">])) {<br />
&nbsp;&nbsp;&nbsp; </span><span class="default">$this</span><span class="keyword">-&gt;</span><span class="default">data</span><span class="keyword">[</span><span class="default">$this</span><span class="keyword">-&gt;</span><span class="default">currentItem</span><span class="keyword">][</span><span class="default">$this</span><span class="keyword">-&gt;</span><span class="default">currentField</span><span class="keyword">] .= </span><span class="default">$cdata</span><span class="keyword">;<br />
} else {<br />
&nbsp;&nbsp;&nbsp; </span><span class="default">$this</span><span class="keyword">-&gt;</span><span class="default">data</span><span class="keyword">[</span><span class="default">$this</span><span class="keyword">-&gt;</span><span class="default">currentItem</span><span class="keyword">][</span><span class="default">$this</span><span class="keyword">-&gt;</span><span class="default">currentField</span><span class="keyword">] = </span><span class="default">$cdata</span><span class="keyword">;<br />
}&nbsp; &nbsp; &nbsp; <br />
</span><span class="default">?&gt;</span>
</span>
</code>
    </div>
   </div>
  </div>
 <div class="foot"></div>
  <a name="46948""></a>
  <div class="note">
   <strong class="user">Philippe Marc</strong>
   <a href="#46948" class="date">28-Oct-2004 07:21</a>
   <div class="text">
    <div class="phpcode">
<code><span class="html">
How to overide the 1024 characters limitation of xml_set_character_data_handler.<br />
Took me some time to find out how to deal with that!<br />
<br />
When calling a basic XML parser: <br />
$parseurXML = xml_parser_create();<br />
xml_set_element_handler($parseurXML, "opentagfunction", "closetagfunction");<br />
xml_set_character_data_handler($parseurXML, "textfunction");<br />
<br />
The textfunction only receive 1024 characters at once, even if the text is 4000 characters long. In facts, the parser seems to split the data in pieces of 1024 characters. The way to handle that is to concatenate them.<br />
<br />
example:<br />
If you have an XML tag called UNIPROT_ABSTRACT containing a 4000 characters protein description:<br />
function textfunction($parser, $text)<br />
&nbsp;&nbsp;&nbsp; {<br />
&nbsp;&nbsp; &nbsp; if ($last_tag_read=='UNIPROT_ABSTRACT') $uniprot.=$text;<br />
&nbsp;&nbsp;&nbsp; }<br />
The function is called 4 times and receives 1024+1024+1024+928 characters that will be concatenated in the $uniprot variable using the ".=" concatenation fonction.<br />
<br />
Easy to do, but not documented!</span>
</code>
    </div>
   </div>
  </div>
 <div class="foot"></div>
  <a name="43992""></a>
  <div class="note">
   <strong class="user">Brad dot Harrison at griffith dot edu dot au</strong>
   <a href="#43992" class="date">11-Jul-2004 10:23</a>
   <div class="text">
    <div class="phpcode">
<code><span class="html">
If you need to trim the white space for HTML code and don't rely on spaces for formatting text (if you are then it is time to use Style Sheets) then this code will come in very useful.<br />
<br />
&nbsp;$data=eregi_replace("&gt;"."[[:space:]]+"."&lt;","&gt;&lt;",$data);<br />
&nbsp;$data=eregi_replace("&gt;"."[[:space:]]+","&gt;",$data);<br />
&nbsp;$data=eregi_replace("[[:space:]]+"."&lt;","&lt;",$data);</span>
</code>
    </div>
   </div>
  </div>
 <div class="foot"></div>
  <a name="37902""></a>
  <div class="note">
   <strong class="user">dan30odd08 at hotmail dot com</strong>
   <a href="#37902" class="date">01-Dec-2003 04:38</a>
   <div class="text">
    <div class="phpcode">
<code><span class="html">
I just want to mention that i ran into a problem when parsing an xml file using the character data handler. If you happen to have a string which is also an internal php function stored in your xml data file and you want to output it as a string the parser dosent seem to recognize it.<br />
&nbsp;&nbsp; I found a way around this problem. In my case i was storing a string with the value read. This would not allow me to output the data so to work around this problem i added a backslash for every character in the data element.<br />
<br />
&nbsp;&nbsp; e.g.&nbsp; &nbsp; &nbsp; &lt;xml&gt;<br />
&nbsp;&nbsp;&nbsp; from&nbsp; &nbsp; &lt;element&gt;read&lt;/element&gt;<br />
&nbsp;&nbsp;&nbsp; to&nbsp; &nbsp; &nbsp;&nbsp; &lt;element&gt;////read&lt;/element&gt;<br />
<br />
i dont know if anyone has ran into this problem or not but i thought i would just put it here just so in case someone is getting stuck with this.</span>
</code>
    </div>
   </div>
  </div>
 <div class="foot"></div>
  <a name="18609""></a>
  <div class="note">
   <strong class="user">ken at positive-edge dot com</strong>
   <a href="#18609" class="date">29-Jan-2002 08:20</a>
   <div class="text">
    <div class="phpcode">
<code><span class="html">
the function handler is called several times when it parses the character data.&nbsp; It doesn't return the entire string as it suggests.&nbsp; There are special exceptions that will always force the parser to stop scanning and call the character data handler.&nbsp; This is when:<br />
<br />
- The parser runs into an Entity Declaration, such as &amp;amp; (&amp;) or &amp;apos; (?)<br />
- The parser finishes parsing an entity<br />
- The parser runs into the new-line character (\n)<br />
- The parser runs into a series of tab characters (\t)<br />
<br />
And perhaps others.<br />
<br />
For instance, if we have this xml content:<br />
<br />
&lt;mytag name=?Ken Egervari? title=?Chief Technology Officer?&gt;<br />
&nbsp;&nbsp;&nbsp; Ken has been Positive Edge&amp;apos;s Chief Technology Officer for 2 years.<br />
&lt;/mytag&gt;<br />
<br />
The parser will call the character data handler 6 times.&nbsp; This is what will happen:<br />
<br />
1&nbsp; &nbsp; \n<br />
2&nbsp; &nbsp; \t<br />
3&nbsp; &nbsp; Ken has been Positive Edge<br />
4&nbsp; &nbsp; ?<br />
5&nbsp; &nbsp; s Chief Technology Officer for 2 years.<br />
6&nbsp; &nbsp; \n<br />
<br />
I hope that helps people out.</span>
</code>
    </div>
   </div>
  </div>
 <div class="foot"></div>
</div>
</div>
</div></div></body></html>
